{"version":3,"file":"scratch-render.js","sources":["webpack://ScratchRender/webpack/bootstrap","webpack://ScratchRender/./node_modules/minilog/lib/common/transform.js","webpack://ScratchRender/external \"twgl.js\"","webpack://ScratchRender/./node_modules/minilog/lib/node/formatters/util.js","webpack://ScratchRender/src/Skin.js","webpack://ScratchRender/src/RenderConstants.js","webpack://ScratchRender/src/ShaderManager.js","webpack://ScratchRender/src/Rectangle.js","webpack://ScratchRender/external \"events\"","webpack://ScratchRender/src/EffectTransform.js","webpack://ScratchRender/external \"scratch-svg-renderer\"","webpack://ScratchRender/./node_modules/minilog/lib/common/minilog.js","webpack://ScratchRender/external \"util\"","webpack://ScratchRender/./node_modules/minilog/lib/web/formatters/util.js","webpack://ScratchRender/src/index.js","webpack://ScratchRender/src/RenderWebGL.js","webpack://ScratchRender/external \"hull.js\"","webpack://ScratchRender/src/BitmapSkin.js","webpack://ScratchRender/src/Silhouette.js","webpack://ScratchRender/src/Drawable.js","webpack://ScratchRender/./src/shaders/sprite.vert","webpack://ScratchRender/./src/shaders/sprite.frag","webpack://ScratchRender/src/PenSkin.js","webpack://ScratchRender/src/SVGSkin.js","webpack://ScratchRender/src/util/svg-text-bubble.js","webpack://ScratchRender/src/util/svg-text-wrapper.js","webpack://ScratchRender/src/util/text-wrapper.js","webpack://ScratchRender/external \"linebreak\"","webpack://ScratchRender/external \"grapheme-breaker\"","webpack://ScratchRender/src/util/log.js","webpack://ScratchRender/./node_modules/minilog/lib/index.js","webpack://ScratchRender/./node_modules/microee/index.js","webpack://ScratchRender/./node_modules/minilog/lib/common/filter.js","webpack://ScratchRender/./node_modules/minilog/lib/node/console.js","webpack://ScratchRender/./node_modules/minilog/lib/node/formatters/clean.js","webpack://ScratchRender/./node_modules/minilog/lib/node/formatters/color.js","webpack://ScratchRender/./node_modules/minilog/lib/node/formatters/npm.js","webpack://ScratchRender/./node_modules/minilog/lib/node/formatters/learnboost.js","webpack://ScratchRender/./node_modules/minilog/lib/node/formatters/minilog.js","webpack://ScratchRender/./node_modules/minilog/lib/node/formatters/withstack.js","webpack://ScratchRender/./node_modules/minilog/lib/node/formatters/time.js","webpack://ScratchRender/./node_modules/minilog/lib/web/console.js","webpack://ScratchRender/./node_modules/minilog/lib/web/formatters/color.js","webpack://ScratchRender/./node_modules/minilog/lib/web/formatters/minilog.js","webpack://ScratchRender/./node_modules/minilog/lib/node/stringify.js","webpack://ScratchRender/external \"stream\"","webpack://ScratchRender/./node_modules/minilog/lib/node/redis.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 13);\n","var microee = require('microee');\n\n// Implements a subset of Node's stream.Transform - in a cross-platform manner.\nfunction Transform() {}\n\nmicroee.mixin(Transform);\n\n// The write() signature is different from Node's\n// --> makes it much easier to work with objects in logs.\n// One of the lessons from v1 was that it's better to target\n// a good browser rather than the lowest common denominator\n// internally.\n// If you want to use external streams, pipe() to ./stringify.js first.\nTransform.prototype.write = function(name, level, args) {\n  this.emit('item', name, level, args);\n};\n\nTransform.prototype.end = function() {\n  this.emit('end');\n  this.removeAllListeners();\n};\n\nTransform.prototype.pipe = function(dest) {\n  var s = this;\n  // prevent double piping\n  s.emit('unpipe', dest);\n  // tell the dest that it's being piped to\n  dest.emit('pipe', s);\n\n  function onItem() {\n    dest.write.apply(dest, Array.prototype.slice.call(arguments));\n  }\n  function onEnd() { !dest._isStdio && dest.end(); }\n\n  s.on('item', onItem);\n  s.on('end', onEnd);\n\n  s.when('unpipe', function(from) {\n    var match = (from === dest) || typeof from == 'undefined';\n    if(match) {\n      s.removeListener('item', onItem);\n      s.removeListener('end', onEnd);\n      dest.emit('unpipe');\n    }\n    return match;\n  });\n\n  return dest;\n};\n\nTransform.prototype.unpipe = function(from) {\n  this.emit('unpipe', from);\n  return this;\n};\n\nTransform.prototype.format = function(dest) {\n  throw new Error([\n    'Warning: .format() is deprecated in Minilog v2! Use .pipe() instead. For example:',\n    'var Minilog = require(\\'minilog\\');',\n    'Minilog',\n    '  .pipe(Minilog.backends.console.formatClean)',\n    '  .pipe(Minilog.backends.console);'].join('\\n'));\n};\n\nTransform.mixin = function(dest) {\n  var o = Transform.prototype, k;\n  for (k in o) {\n    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);\n  }\n};\n\nmodule.exports = Transform;\n","module.exports = require(\"twgl.js\");","var styles = {\n    //styles\n    'bold'      : ['\\033[1m',  '\\033[22m'],\n    'italic'    : ['\\033[3m',  '\\033[23m'],\n    'underline' : ['\\033[4m',  '\\033[24m'],\n    'inverse'   : ['\\033[7m',  '\\033[27m'],\n    //grayscale\n    'white'     : ['\\033[37m', '\\033[39m'],\n    'grey'      : ['\\033[90m', '\\033[39m'],\n    'black'     : ['\\033[30m', '\\033[39m'],\n    //colors\n    'blue'      : ['\\033[34m', '\\033[39m'],\n    'cyan'      : ['\\033[36m', '\\033[39m'],\n    'green'     : ['\\033[32m', '\\033[39m'],\n    'magenta'   : ['\\033[35m', '\\033[39m'],\n    'red'       : ['\\033[31m', '\\033[39m'],\n    'yellow'    : ['\\033[33m', '\\033[39m']\n  };\n\nexports.levelMap = { debug: 1, info: 2, warn: 3, error: 4 };\n\nexports.style = function(str, style) {\n  return styles[style][0] + str + styles[style][1];\n}\n\n","const EventEmitter = require('events');\n\nconst twgl = require('twgl.js');\n\nconst RenderConstants = require('./RenderConstants');\nconst Silhouette = require('./Silhouette');\n\n/**\n * Truncate a number into what could be stored in a 32 bit floating point value.\n * @param {number} num Number to truncate.\n * @return {number} Truncated value.\n */\nconst toFloat32 = (function () {\n    const memory = new Float32Array(1);\n    return function (num) {\n        memory[0] = num;\n        return memory[0];\n    };\n}());\n\nclass Skin extends EventEmitter {\n    /**\n     * Create a Skin, which stores and/or generates textures for use in rendering.\n     * @param {int} id - The unique ID for this Skin.\n     * @constructor\n     */\n    constructor (id) {\n        super();\n\n        /** @type {int} */\n        this._id = id;\n\n        /** @type {Vec3} */\n        this._rotationCenter = twgl.v3.create(0, 0);\n\n        /**\n         * The uniforms to be used by the vertex and pixel shaders.\n         * Some of these are used by other parts of the renderer as well.\n         * @type {Object.<string,*>}\n         * @private\n         */\n        this._uniforms = {\n            /**\n             * The nominal (not necessarily current) size of the current skin.\n             * @type {Array<number>}\n             */\n            u_skinSize: [0, 0],\n\n            /**\n             * The actual WebGL texture object for the skin.\n             * @type {WebGLTexture}\n             */\n            u_skin: null\n        };\n\n        /**\n         * A silhouette to store touching data, skins are responsible for keeping it up to date.\n         * @private\n         */\n        this._silhouette = new Silhouette();\n\n        this.setMaxListeners(RenderConstants.SKIN_SHARE_SOFT_LIMIT);\n    }\n\n    /**\n     * Dispose of this object. Do not use it after calling this method.\n     */\n    dispose () {\n        this._id = RenderConstants.ID_NONE;\n    }\n\n    /**\n     * @returns {boolean} true for a raster-style skin (like a BitmapSkin), false for vector-style (like SVGSkin).\n     */\n    get isRaster () {\n        return false;\n    }\n\n    /**\n     * @return {int} the unique ID for this Skin.\n     */\n    get id () {\n        return this._id;\n    }\n\n    /**\n     * @returns {Vec3} the origin, in object space, about which this Skin should rotate.\n     */\n    get rotationCenter () {\n        return this._rotationCenter;\n    }\n\n    /**\n     * @abstract\n     * @return {Array<number>} the \"native\" size, in texels, of this skin.\n     */\n    get size () {\n        return [0, 0];\n    }\n\n    /**\n     * Set the origin, in object space, about which this Skin should rotate.\n     * @param {number} x - The x coordinate of the new rotation center.\n     * @param {number} y - The y coordinate of the new rotation center.\n     * @fires Skin.event:WasAltered\n     */\n    setRotationCenter (x, y) {\n        const emptySkin = this.size[0] === 0 && this.size[1] === 0;\n        // Compare a 32 bit x and y value against the stored 32 bit center\n        // values.\n        const changed = (\n            toFloat32(x) !== this._rotationCenter[0] ||\n            toFloat32(y) !== this._rotationCenter[1]);\n        if (!emptySkin && changed) {\n            this._rotationCenter[0] = x;\n            this._rotationCenter[1] = y;\n            this.emit(Skin.Events.WasAltered);\n        }\n    }\n\n    /**\n     * Get the center of the current bounding box\n     * @return {Array<number>} the center of the current bounding box\n     */\n    calculateRotationCenter () {\n        return [this.size[0] / 2, this.size[1] / 2];\n    }\n\n    /**\n     * @abstract\n     * @param {Array<number>} scale - The scaling factors to be used.\n     * @return {WebGLTexture} The GL texture representation of this skin when drawing at the given size.\n     */\n    // eslint-disable-next-line no-unused-vars\n    getTexture (scale) {\n        return null;\n    }\n\n    /**\n     * Update and returns the uniforms for this skin.\n     * @param {Array<number>} scale - The scaling factors to be used.\n     * @returns {object.<string, *>} the shader uniforms to be used when rendering with this Skin.\n     */\n    getUniforms (scale) {\n        this._uniforms.u_skin = this.getTexture(scale);\n        this._uniforms.u_skinSize = this.size;\n        return this._uniforms;\n    }\n\n    /**\n     * If the skin defers silhouette operations until the last possible minute,\n     * this will be called before isTouching uses the silhouette.\n     * @abstract\n     */\n    updateSilhouette () {}\n\n    /**\n     * Does this point touch an opaque or translucent point on this skin?\n     * Nearest Neighbor version\n     * @param {twgl.v3} vec A texture coordinate.\n     * @return {boolean} Did it touch?\n     */\n    isTouchingNearest (vec) {\n        return this._silhouette.isTouchingNearest(vec);\n    }\n\n    /**\n     * Does this point touch an opaque or translucent point on this skin?\n     * Linear Interpolation version\n     * @param {twgl.v3} vec A texture coordinate.\n     * @return {boolean} Did it touch?\n     */\n    isTouchingLinear (vec) {\n        return this._silhouette.isTouchingLinear(vec);\n    }\n\n}\n\n/**\n * These are the events which can be emitted by instances of this class.\n * @enum {string}\n */\nSkin.Events = {\n    /**\n     * Emitted when anything about the Skin has been altered, such as the appearance or rotation center.\n     * @event Skin.event:WasAltered\n     */\n    WasAltered: 'WasAltered'\n};\n\nmodule.exports = Skin;\n","/** @module RenderConstants */\n\n/**\n * Various constants meant for use throughout the renderer.\n * @enum\n */\nmodule.exports = {\n    /**\n     * The ID value to use for \"no item\" or when an object has been disposed.\n     * @const {int}\n     */\n    ID_NONE: -1,\n\n    /**\n     * Optimize for fewer than this number of Drawables sharing the same Skin.\n     * Going above this may cause middleware warnings or a performance penalty but should otherwise behave correctly.\n     * @const {int}\n     */\n    SKIN_SHARE_SOFT_LIMIT: 301,\n\n    /**\n     * @enum {string}\n     */\n    Events: {\n        /**\n         * NativeSizeChanged event\n         *\n         * @event RenderWebGL#event:NativeSizeChanged\n         * @type {object}\n         * @property {Array<int>} newSize - the new size of the renderer\n         */\n        NativeSizeChanged: 'NativeSizeChanged'\n    }\n};\n","const twgl = require('twgl.js');\n\n\nclass ShaderManager {\n    /**\n     * @param {WebGLRenderingContext} gl WebGL rendering context to create shaders for\n     * @constructor\n     */\n    constructor (gl) {\n        this._gl = gl;\n\n        /**\n         * The cache of all shaders compiled so far, filled on demand.\n         * @type {Object<ShaderManager.DRAW_MODE, Array<ProgramInfo>>}\n         * @private\n         */\n        this._shaderCache = {};\n        for (const modeName in ShaderManager.DRAW_MODE) {\n            if (ShaderManager.DRAW_MODE.hasOwnProperty(modeName)) {\n                this._shaderCache[modeName] = [];\n            }\n        }\n    }\n\n    /**\n     * Fetch the shader for a particular set of active effects.\n     * Build the shader if necessary.\n     * @param {ShaderManager.DRAW_MODE} drawMode Draw normally, silhouette, etc.\n     * @param {int} effectBits Bitmask representing the enabled effects.\n     * @returns {ProgramInfo} The shader's program info.\n     */\n    getShader (drawMode, effectBits) {\n        const cache = this._shaderCache[drawMode];\n        if (drawMode === ShaderManager.DRAW_MODE.silhouette) {\n            // Silhouette mode isn't affected by these effects.\n            effectBits &= ~(ShaderManager.EFFECT_INFO.color.mask | ShaderManager.EFFECT_INFO.brightness.mask);\n        }\n        let shader = cache[effectBits];\n        if (!shader) {\n            shader = cache[effectBits] = this._buildShader(drawMode, effectBits);\n        }\n        return shader;\n    }\n\n    /**\n     * Build the shader for a particular set of active effects.\n     * @param {ShaderManager.DRAW_MODE} drawMode Draw normally, silhouette, etc.\n     * @param {int} effectBits Bitmask representing the enabled effects.\n     * @returns {ProgramInfo} The new shader's program info.\n     * @private\n     */\n    _buildShader (drawMode, effectBits) {\n        const numEffects = ShaderManager.EFFECTS.length;\n\n        const defines = [\n            `#define DRAW_MODE_${drawMode}`\n        ];\n        for (let index = 0; index < numEffects; ++index) {\n            if ((effectBits & (1 << index)) !== 0) {\n                defines.push(`#define ENABLE_${ShaderManager.EFFECTS[index]}`);\n            }\n        }\n\n        const definesText = `${defines.join('\\n')}\\n`;\n\n        /* eslint-disable global-require */\n        const vsFullText = definesText + require('raw-loader!./shaders/sprite.vert');\n        const fsFullText = definesText + require('raw-loader!./shaders/sprite.frag');\n        /* eslint-enable global-require */\n\n        return twgl.createProgramInfo(this._gl, [vsFullText, fsFullText]);\n    }\n}\n\n/**\n * @typedef {object} ShaderManager.Effect\n * @prop {int} mask - The bit in 'effectBits' representing the effect.\n * @prop {function} converter - A conversion function which takes a Scratch value (generally in the range\n *   0..100 or -100..100) and maps it to a value useful to the shader. This\n *   mapping may not be reversible.\n * @prop {boolean} shapeChanges - Whether the effect could change the drawn shape.\n */\n\n/**\n * Mapping of each effect name to info about that effect.\n * @enum {ShaderManager.Effect}\n */\nShaderManager.EFFECT_INFO = {\n    /** Color effect */\n    color: {\n        uniformName: 'u_color',\n        mask: 1 << 0,\n        converter: x => (x / 200) % 1,\n        shapeChanges: false\n    },\n    /** Fisheye effect */\n    fisheye: {\n        uniformName: 'u_fisheye',\n        mask: 1 << 1,\n        converter: x => Math.max(0, (x + 100) / 100),\n        shapeChanges: true\n    },\n    /** Whirl effect */\n    whirl: {\n        uniformName: 'u_whirl',\n        mask: 1 << 2,\n        converter: x => -x * Math.PI / 180,\n        shapeChanges: true\n    },\n    /** Pixelate effect */\n    pixelate: {\n        uniformName: 'u_pixelate',\n        mask: 1 << 3,\n        converter: x => Math.abs(x) / 10,\n        shapeChanges: true\n    },\n    /** Mosaic effect */\n    mosaic: {\n        uniformName: 'u_mosaic',\n        mask: 1 << 4,\n        converter: x => {\n            x = Math.round((Math.abs(x) + 10) / 10);\n            /** @todo cap by Math.min(srcWidth, srcHeight) */\n            return Math.max(1, Math.min(x, 512));\n        },\n        shapeChanges: true\n    },\n    /** Brightness effect */\n    brightness: {\n        uniformName: 'u_brightness',\n        mask: 1 << 5,\n        converter: x => Math.max(-100, Math.min(x, 100)) / 100,\n        shapeChanges: false\n    },\n    /** Ghost effect */\n    ghost: {\n        uniformName: 'u_ghost',\n        mask: 1 << 6,\n        converter: x => 1 - (Math.max(0, Math.min(x, 100)) / 100),\n        shapeChanges: false\n    }\n};\n\n/**\n * The name of each supported effect.\n * @type {Array}\n */\nShaderManager.EFFECTS = Object.keys(ShaderManager.EFFECT_INFO);\n\n/**\n * The available draw modes.\n * @readonly\n * @enum {string}\n */\nShaderManager.DRAW_MODE = {\n    /**\n     * Draw normally.\n     */\n    default: 'default',\n\n    /**\n     * Draw a silhouette using a solid color.\n     */\n    silhouette: 'silhouette',\n\n    /**\n     * Draw only the parts of the drawable which match a particular color.\n     */\n    colorMask: 'colorMask',\n\n    /**\n     * Sample a \"texture\" to draw a line with caps.\n     */\n    lineSample: 'lineSample',\n\n    /**\n     * Draw normally except for pre-multiplied alpha\n     */\n    stamp: 'stamp'\n};\n\nmodule.exports = ShaderManager;\n","class Rectangle {\n    /**\n     * A utility for creating and comparing axis-aligned rectangles.\n     * Rectangles are always initialized to the \"largest possible rectangle\";\n     * use one of the init* methods below to set up a particular rectangle.\n     * @constructor\n     */\n    constructor () {\n        this.left = -Infinity;\n        this.right = Infinity;\n        this.bottom = -Infinity;\n        this.top = Infinity;\n    }\n\n    /**\n     * Initialize a Rectangle from given Scratch-coordinate bounds.\n     * @param {number} left Left bound of the rectangle.\n     * @param {number} right Right bound of the rectangle.\n     * @param {number} bottom Bottom bound of the rectangle.\n     * @param {number} top Top bound of the rectangle.\n     */\n    initFromBounds (left, right, bottom, top) {\n        this.left = left;\n        this.right = right;\n        this.bottom = bottom;\n        this.top = top;\n    }\n\n    /**\n     * Initialize a Rectangle to the minimum AABB around a set of points.\n     * @param {Array<Array<number>>} points Array of [x, y] points.\n     */\n    initFromPointsAABB (points) {\n        this.left = Infinity;\n        this.right = -Infinity;\n        this.top = -Infinity;\n        this.bottom = Infinity;\n\n        for (let i = 0; i < points.length; i++) {\n            const x = points[i][0];\n            const y = points[i][1];\n            if (x < this.left) {\n                this.left = x;\n            }\n            if (x > this.right) {\n                this.right = x;\n            }\n            if (y > this.top) {\n                this.top = y;\n            }\n            if (y < this.bottom) {\n                this.bottom = y;\n            }\n        }\n    }\n\n    /**\n     * Determine if this Rectangle intersects some other.\n     * Note that this is a comparison assuming the Rectangle was\n     * initialized with Scratch-space bounds or points.\n     * @param {!Rectangle} other Rectangle to check if intersecting.\n     * @return {boolean} True if this Rectangle intersects other.\n     */\n    intersects (other) {\n        return (\n            this.left <= other.right &&\n            other.left <= this.right &&\n            this.top >= other.bottom &&\n            other.top >= this.bottom\n        );\n    }\n\n    /**\n     * Determine if this Rectangle fully contains some other.\n     * Note that this is a comparison assuming the Rectangle was\n     * initialized with Scratch-space bounds or points.\n     * @param {!Rectangle} other Rectangle to check if fully contained.\n     * @return {boolean} True if this Rectangle fully contains other.\n     */\n    contains (other) {\n        return (\n            other.left > this.left &&\n            other.right < this.right &&\n            other.top < this.top &&\n            other.bottom > this.bottom\n        );\n    }\n\n    /**\n     * Clamp a Rectangle to bounds.\n     * @param {number} left Left clamp.\n     * @param {number} right Right clamp.\n     * @param {number} bottom Bottom clamp.\n     * @param {number} top Top clamp.\n     */\n    clamp (left, right, bottom, top) {\n        this.left = Math.max(this.left, left);\n        this.right = Math.min(this.right, right);\n        this.bottom = Math.max(this.bottom, bottom);\n        this.top = Math.min(this.top, top);\n        // Ensure rectangle coordinates in order.\n        this.left = Math.min(this.left, this.right);\n        this.right = Math.max(this.right, this.left);\n        this.bottom = Math.min(this.bottom, this.top);\n        this.top = Math.max(this.top, this.bottom);\n    }\n\n    /**\n     * Push out the Rectangle to integer bounds.\n     */\n    snapToInt () {\n        this.left = Math.floor(this.left);\n        this.right = Math.ceil(this.right);\n        this.bottom = Math.floor(this.bottom);\n        this.top = Math.ceil(this.top);\n    }\n\n    /**\n     * Compute the intersection of two bounding Rectangles.\n     * Could be an impossible box if they don't intersect.\n     * @param {Rectangle} a One rectangle\n     * @param {Rectangle} b Other rectangle\n     * @param {?Rectangle} result A resulting storage rectangle  (safe to pass\n     *                            a or b if you want to overwrite one)\n     * @returns {Rectangle} resulting rectangle\n     */\n    static intersect (a, b, result = new Rectangle()) {\n        result.left = Math.max(a.left, b.left);\n        result.right = Math.min(a.right, b.right);\n        result.top = Math.min(a.top, b.top);\n        result.bottom = Math.max(a.bottom, b.bottom);\n\n        return result;\n    }\n\n    /**\n     * Compute the union of two bounding Rectangles.\n     * @param {Rectangle} a One rectangle\n     * @param {Rectangle} b Other rectangle\n     * @param {?Rectangle} result A resulting storage rectangle  (safe to pass\n     *                            a or b if you want to overwrite one)\n     * @returns {Rectangle} resulting rectangle\n     */\n    static union (a, b, result = new Rectangle()) {\n        result.left = Math.min(a.left, b.left);\n        result.right = Math.max(a.right, b.right);\n        // Scratch Space - +y is up\n        result.top = Math.max(a.top, b.top);\n        result.bottom = Math.min(a.bottom, b.bottom);\n        return result;\n    }\n\n    /**\n     * Width of the Rectangle.\n     * @return {number} Width of rectangle.\n     */\n    get width () {\n        return Math.abs(this.left - this.right);\n    }\n\n    /**\n     * Height of the Rectangle.\n     * @return {number} Height of rectangle.\n     */\n    get height () {\n        return Math.abs(this.top - this.bottom);\n    }\n\n}\n\nmodule.exports = Rectangle;\n","module.exports = require(\"events\");","/**\n * @fileoverview\n * A utility to transform a texture coordinate to another texture coordinate\n * representing how the shaders apply effects.\n */\n\nconst twgl = require('twgl.js');\n\nconst ShaderManager = require('./ShaderManager');\n\n/**\n * A texture coordinate is between 0 and 1. 0.5 is the center position.\n * @const {number}\n */\nconst CENTER_X = 0.5;\n\n/**\n * A texture coordinate is between 0 and 1. 0.5 is the center position.\n * @const {number}\n */\nconst CENTER_Y = 0.5;\n\n// color conversions grabbed from https://gist.github.com/mjackson/5311256\n\n/**\n * Converts an RGB color value to HSL. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n * Assumes r, g, and b are contained in the set [0, 255] and\n * returns h, s, and l in the set [0, 1].\n *\n * @param   {number}  r       The red color value\n * @param   {number}  g       The green color value\n * @param   {number}  b       The blue color value\n * @return  {Array}           The HSL representation\n */\nconst rgbToHsl = ([r, g, b]) => {\n    r /= 255;\n    g /= 255;\n    b /= 255;\n\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    let h;\n    let s;\n    const l = (max + min) / 2;\n\n    if (max === min) {\n        h = s = 0; // achromatic\n    } else {\n        const d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n        switch (max) {\n        case r: h = ((g - b) / d) + (g < b ? 6 : 0); break;\n        case g: h = ((b - r) / d) + 2; break;\n        case b: h = ((r - g) / d) + 4; break;\n        }\n\n        h /= 6;\n    }\n\n    return [h, s, l];\n};\n\n/**\n * Helper function for hslToRgb is called with varying 't' values to get\n * red green and blue values from the p/q/t color space calculations\n * @param {number} p vector coordinates\n * @param {number} q vector coordinates\n * @param {number} t vector coordinates\n * @return {number} amount of r/g/b byte\n */\nconst hue2rgb = (p, q, t) => {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + ((q - p) * 6 * t);\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + ((q - p) * ((2 / 3) - t) * 6);\n    return p;\n};\n\n\n/**\n * Converts an HSL color value to RGB. Conversion formula\n * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n * Assumes h, s, and l are contained in the set [0, 1] and\n * returns r, g, and b in the set [0, 255].\n *\n * @param   {number}  h       The hue\n * @param   {number}  s       The saturation\n * @param   {number}  l       The lightness\n * @return  {Array}           The RGB representation\n */\nconst hslToRgb = ([h, s, l]) => {\n    let r;\n    let g;\n    let b;\n\n    if (s === 0) {\n        r = g = b = l; // achromatic\n    } else {\n\n        const q = l < 0.5 ? l * (1 + s) : l + s - (l * s);\n        const p = (2 * l) - q;\n\n        r = hue2rgb(p, q, h + (1 / 3));\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - (1 / 3));\n    }\n\n    return [r * 255, g * 255, b * 255];\n};\n\nclass EffectTransform {\n\n    /**\n     * Transform a color given the drawables effect uniforms.  Will apply\n     * Ghost and Color and Brightness effects.\n     * @param {Drawable} drawable The drawable to get uniforms from.\n     * @param {Uint8ClampedArray} color4b The initial color.\n     * @param {Uint8ClampedArary} [dst] Working space to save the color in (is returned)\n     * @param {number} [effectMask] A bitmask for which effects to use. Optional.\n     * @returns {Uint8ClampedArray} dst filled with the transformed color\n     */\n    static transformColor (drawable, color4b, dst, effectMask) {\n        dst = dst || new Uint8ClampedArray(4);\n        effectMask = effectMask || 0xffffffff;\n        dst.set(color4b);\n        if (dst[3] === 0) {\n            return dst;\n        }\n\n        const uniforms = drawable.getUniforms();\n        const effects = drawable.getEnabledEffects() & effectMask;\n\n        if ((effects & ShaderManager.EFFECT_INFO.ghost.mask) !== 0) {\n            // gl_FragColor.a *= u_ghost\n            dst[3] *= uniforms.u_ghost;\n        }\n\n        const enableColor = (effects & ShaderManager.EFFECT_INFO.color.mask) !== 0;\n        const enableBrightness = (effects & ShaderManager.EFFECT_INFO.brightness.mask) !== 0;\n\n        if (enableColor || enableBrightness) {\n            // vec3 hsl = convertRGB2HSL(gl_FragColor.xyz);\n            const hsl = rgbToHsl(dst);\n\n            if (enableColor) {\n                // this code forces grayscale values to be slightly saturated\n                // so that some slight change of hue will be visible\n                // const float minLightness = 0.11 / 2.0;\n                const minL = 0.11 / 2.0;\n                // const float minSaturation = 0.09;\n                const minS = 0.09;\n                // if (hsl.z < minLightness) hsl = vec3(0.0, 1.0, minLightness);\n                if (hsl[2] < minL) {\n                    hsl[0] = 0;\n                    hsl[1] = 1;\n                    hsl[2] = minL;\n                // else if (hsl.y < minSaturation) hsl = vec3(0.0, minSaturation, hsl.z);\n                } else if (hsl[1] < minS) {\n                    hsl[0] = 0;\n                    hsl[1] = minS;\n                }\n\n                // hsl.x = mod(hsl.x + u_color, 1.0);\n                // if (hsl.x < 0.0) hsl.x += 1.0;\n                hsl[0] = (uniforms.u_color + hsl[0] + 1) % 1;\n            }\n\n            if (enableBrightness) {\n                // hsl.z = clamp(hsl.z + u_brightness, 0.0, 1.0);\n                hsl[2] = Math.min(1, hsl[2] + uniforms.u_brightness);\n            }\n            // gl_FragColor.rgb = convertHSL2RGB(hsl);\n            dst.set(hslToRgb(hsl));\n        }\n\n        return dst;\n    }\n\n    /**\n     * Transform a texture coordinate to one that would be select after applying shader effects.\n     * @param {Drawable} drawable The drawable whose effects to emulate.\n     * @param {twgl.v3} vec The texture coordinate to transform.\n     * @param {?twgl.v3} dst A place to store the output coordinate.\n     * @return {twgl.v3} dst - The coordinate after being transform by effects.\n     */\n    static transformPoint (drawable, vec, dst = twgl.v3.create()) {\n        twgl.v3.copy(vec, dst);\n\n        const uniforms = drawable.getUniforms();\n        const effects = drawable.getEnabledEffects();\n\n        if ((effects & ShaderManager.EFFECT_INFO.mosaic.mask) !== 0) {\n            // texcoord0 = fract(u_mosaic * texcoord0);\n            dst[0] = uniforms.u_mosaic * dst[0] % 1;\n            dst[1] = uniforms.u_mosaic * dst[1] % 1;\n        }\n        if ((effects & ShaderManager.EFFECT_INFO.pixelate.mask) !== 0) {\n            const skinUniforms = drawable.skin.getUniforms();\n            // vec2 pixelTexelSize = u_skinSize / u_pixelate;\n            const texelX = skinUniforms.u_skinSize[0] * uniforms.u_pixelate;\n            const texelY = skinUniforms.u_skinSize[1] * uniforms.u_pixelate;\n            // texcoord0 = (floor(texcoord0 * pixelTexelSize) + kCenter) /\n            //   pixelTexelSize;\n            dst[0] = (Math.floor(dst[0] * texelX) + CENTER_X) / texelX;\n            dst[1] = (Math.floor(dst[1] * texelY) + CENTER_Y) / texelY;\n        }\n        if ((effects & ShaderManager.EFFECT_INFO.whirl.mask) !== 0) {\n            // const float kRadius = 0.5;\n            const RADIUS = 0.5;\n            // vec2 offset = texcoord0 - kCenter;\n            const offsetX = dst[0] - CENTER_X;\n            const offsetY = dst[1] - CENTER_Y;\n            // float offsetMagnitude = length(offset);\n            const offsetMagnitude = Math.sqrt(Math.pow(offsetX, 2) + Math.pow(offsetY, 2));\n            // float whirlFactor = max(1.0 - (offsetMagnitude / kRadius), 0.0);\n            const whirlFactor = Math.max(1.0 - (offsetMagnitude / RADIUS), 0.0);\n            // float whirlActual = u_whirl * whirlFactor * whirlFactor;\n            const whirlActual = uniforms.u_whirl * whirlFactor * whirlFactor;\n            // float sinWhirl = sin(whirlActual);\n            const sinWhirl = Math.sin(whirlActual);\n            // float cosWhirl = cos(whirlActual);\n            const cosWhirl = Math.cos(whirlActual);\n            // mat2 rotationMatrix = mat2(\n            //     cosWhirl, -sinWhirl,\n            //     sinWhirl, cosWhirl\n            // );\n            const rot1 = cosWhirl;\n            const rot2 = -sinWhirl;\n            const rot3 = sinWhirl;\n            const rot4 = cosWhirl;\n\n            // texcoord0 = rotationMatrix * offset + kCenter;\n            dst[0] = (rot1 * offsetX) + (rot3 * offsetY) + CENTER_X;\n            dst[1] = (rot2 * offsetX) + (rot4 * offsetY) + CENTER_Y;\n        }\n        if ((effects & ShaderManager.EFFECT_INFO.fisheye.mask) !== 0) {\n            // vec2 vec = (texcoord0 - kCenter) / kCenter;\n            const vX = (dst[0] - CENTER_X) / CENTER_X;\n            const vY = (dst[1] - CENTER_Y) / CENTER_Y;\n            // float vecLength = length(vec);\n            const vLength = Math.sqrt((vX * vX) + (vY * vY));\n            // float r = pow(min(vecLength, 1.0), u_fisheye) * max(1.0, vecLength);\n            const r = Math.pow(Math.min(vLength, 1), uniforms.u_fisheye) * Math.max(1, vLength);\n            // vec2 unit = vec / vecLength;\n            const unitX = vX / vLength;\n            const unitY = vY / vLength;\n            // texcoord0 = kCenter + r * unit * kCenter;\n            dst[0] = CENTER_X + (r * unitX * CENTER_X);\n            dst[1] = CENTER_Y + (r * unitY * CENTER_Y);\n        }\n\n        return dst;\n    }\n}\n\nmodule.exports = EffectTransform;\n","module.exports = require(\"scratch-svg-renderer\");","var Transform = require('./transform.js'),\n    Filter = require('./filter.js');\n\nvar log = new Transform(),\n    slice = Array.prototype.slice;\n\nexports = module.exports = function create(name) {\n  var o   = function() { log.write(name, undefined, slice.call(arguments)); return o; };\n  o.debug = function() { log.write(name, 'debug', slice.call(arguments)); return o; };\n  o.info  = function() { log.write(name, 'info',  slice.call(arguments)); return o; };\n  o.warn  = function() { log.write(name, 'warn',  slice.call(arguments)); return o; };\n  o.error = function() { log.write(name, 'error', slice.call(arguments)); return o; };\n  o.log   = o.debug; // for interface compliance with Node and browser consoles\n  o.suggest = exports.suggest;\n  o.format = log.format;\n  return o;\n};\n\n// filled in separately\nexports.defaultBackend = exports.defaultFormatter = null;\n\nexports.pipe = function(dest) {\n  return log.pipe(dest);\n};\n\nexports.end = exports.unpipe = exports.disable = function(from) {\n  return log.unpipe(from);\n};\n\nexports.Transform = Transform;\nexports.Filter = Filter;\n// this is the default filter that's applied when .enable() is called normally\n// you can bypass it completely and set up your own pipes\nexports.suggest = new Filter();\n\nexports.enable = function() {\n  if(exports.defaultFormatter) {\n    return log.pipe(exports.suggest) // filter\n              .pipe(exports.defaultFormatter) // formatter\n              .pipe(exports.defaultBackend); // backend\n  }\n  return log.pipe(exports.suggest) // filter\n            .pipe(exports.defaultBackend); // formatter\n};\n\n","module.exports = require(\"util\");","var hex = {\n  black: '#000',\n  red: '#c23621',\n  green: '#25bc26',\n  yellow: '#bbbb00',\n  blue:  '#492ee1',\n  magenta: '#d338d3',\n  cyan: '#33bbc8',\n  gray: '#808080',\n  purple: '#708'\n};\nfunction color(fg, isInverse) {\n  if(isInverse) {\n    return 'color: #fff; background: '+hex[fg]+';';\n  } else {\n    return 'color: '+hex[fg]+';';\n  }\n}\n\nmodule.exports = color;\n","const RenderWebGL = require('./RenderWebGL');\n\n/**\n * Export for NPM & Node.js\n * @type {RenderWebGL}\n */\nmodule.exports = RenderWebGL;\n","const EventEmitter = require('events');\n\nconst hull = require('hull.js');\nconst twgl = require('twgl.js');\n\nconst BitmapSkin = require('./BitmapSkin');\nconst Drawable = require('./Drawable');\nconst Rectangle = require('./Rectangle');\nconst PenSkin = require('./PenSkin');\nconst RenderConstants = require('./RenderConstants');\nconst ShaderManager = require('./ShaderManager');\nconst SVGSkin = require('./SVGSkin');\nconst SVGTextBubble = require('./util/svg-text-bubble');\nconst EffectTransform = require('./EffectTransform');\nconst log = require('./util/log');\n\nconst __isTouchingDrawablesPoint = twgl.v3.create();\nconst __candidatesBounds = new Rectangle();\nconst __touchingColor = new Uint8ClampedArray(4);\nconst __blendColor = new Uint8ClampedArray(4);\n\n// More pixels than this and we give up to the GPU and take the cost of readPixels\n// Width * Height * Number of drawables at location\nconst __cpuTouchingColorPixelCount = 4e4;\n\n/**\n * @callback RenderWebGL#idFilterFunc\n * @param {int} drawableID The ID to filter.\n * @return {bool} True if the ID passes the filter, otherwise false.\n */\n\n/**\n * Maximum touch size for a picking check.\n * @todo Figure out a reasonable max size. Maybe this should be configurable?\n * @type {Array<int>}\n * @memberof RenderWebGL\n */\nconst MAX_TOUCH_SIZE = [3, 3];\n\n/**\n * Passed to the uniforms for mask in touching color\n */\nconst MASK_TOUCHING_COLOR_TOLERANCE = 2;\n\n/**\n * Determines if the mask color is \"close enough\" (only test the 6 top bits for\n * each color).  These bit masks are what scratch 2 used to use, so we do the same.\n * @param {Uint8Array} a A color3b or color4b value.\n * @param {Uint8Array} b A color3b or color4b value.\n * @returns {boolean} If the colors match within the parameters.\n */\nconst maskMatches = (a, b) => (\n    // has some non-alpha component to test against\n    a[3] > 0 &&\n    (a[0] & 0b11111100) === (b[0] & 0b11111100) &&\n    (a[1] & 0b11111100) === (b[1] & 0b11111100) &&\n    (a[2] & 0b11111100) === (b[2] & 0b11111100)\n);\n\n/**\n * Determines if the given color is \"close enough\" (only test the 5 top bits for\n * red and green, 4 bits for blue).  These bit masks are what scratch 2 used to use,\n * so we do the same.\n * @param {Uint8Array} a A color3b or color4b value.\n * @param {Uint8Array} b A color3b or color4b value / or a larger array when used with offsets\n * @param {number} offset An offset into the `b` array, which lets you use a larger array to test\n *                  multiple values at the same time.\n * @returns {boolean} If the colors match within the parameters.\n */\nconst colorMatches = (a, b, offset) => (\n    (a[0] & 0b11111000) === (b[offset + 0] & 0b11111000) &&\n    (a[1] & 0b11111000) === (b[offset + 1] & 0b11111000) &&\n    (a[2] & 0b11110000) === (b[offset + 2] & 0b11110000)\n);\n\n/**\n * Sprite Fencing - The number of pixels a sprite is required to leave remaining\n * onscreen around the edge of the staging area.\n * @type {number}\n */\nconst FENCE_WIDTH = 15;\n\n\nclass RenderWebGL extends EventEmitter {\n    /**\n     * Check if this environment appears to support this renderer before attempting to create an instance.\n     * Catching an exception from the constructor is also a valid way to test for (lack of) support.\n     * @param {canvas} [optCanvas] - An optional canvas to use for the test. Otherwise a temporary canvas will be used.\n     * @returns {boolean} - True if this environment appears to support this renderer, false otherwise.\n     */\n    static isSupported (optCanvas) {\n        try {\n            // Create the context the same way that the constructor will: attributes may make the difference.\n            return !!RenderWebGL._getContext(optCanvas || document.createElement('canvas'));\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Ask TWGL to create a rendering context with the attributes used by this renderer.\n     * @param {canvas} canvas - attach the context to this canvas.\n     * @returns {WebGLRenderingContext} - a TWGL rendering context (backed by either WebGL 1.0 or 2.0).\n     * @private\n     */\n    static _getContext (canvas) {\n        return twgl.getWebGLContext(canvas, {alpha: false, stencil: true});\n    }\n\n    /**\n     * Create a renderer for drawing Scratch sprites to a canvas using WebGL.\n     * Coordinates will default to Scratch 2.0 values if unspecified.\n     * The stage's \"native\" size will be calculated from the these coordinates.\n     * For example, the defaults result in a native size of 480x360.\n     * Queries such as \"touching color?\" will always execute at the native size.\n     * @see RenderWebGL#setStageSize\n     * @see RenderWebGL#resize\n     * @param {canvas} canvas The canvas to draw onto.\n     * @param {int} [xLeft=-240] The x-coordinate of the left edge.\n     * @param {int} [xRight=240] The x-coordinate of the right edge.\n     * @param {int} [yBottom=-180] The y-coordinate of the bottom edge.\n     * @param {int} [yTop=180] The y-coordinate of the top edge.\n     * @constructor\n     * @listens RenderWebGL#event:NativeSizeChanged\n     */\n    constructor (canvas, xLeft, xRight, yBottom, yTop) {\n        super();\n\n        /** @type {WebGLRenderingContext} */\n        const gl = this._gl = RenderWebGL._getContext(canvas);\n        if (!gl) {\n            throw new Error('Could not get WebGL context: this browser or environment may not support WebGL.');\n        }\n\n        /** @type {Drawable[]} */\n        this._allDrawables = [];\n\n        /** @type {Skin[]} */\n        this._allSkins = [];\n\n        /** @type {Array<int>} */\n        this._drawList = [];\n\n        // A list of layer group names in the order they should appear\n        // from furthest back to furthest in front.\n        /** @type {Array<String>} */\n        this._groupOrdering = [];\n\n        /**\n         * @typedef LayerGroup\n         * @property {int} groupIndex The relative position of this layer group in the group ordering\n         * @property {int} drawListOffset The absolute position of this layer group in the draw list\n         * This number gets updated as drawables get added to or deleted from the draw list.\n         */\n\n        // Map of group name to layer group\n        /** @type {Object.<string, LayerGroup>} */\n        this._layerGroups = {};\n\n        /** @type {int} */\n        this._nextDrawableId = RenderConstants.ID_NONE + 1;\n\n        /** @type {int} */\n        this._nextSkinId = RenderConstants.ID_NONE + 1;\n\n        /** @type {module:twgl/m4.Mat4} */\n        this._projection = twgl.m4.identity();\n\n        /** @type {ShaderManager} */\n        this._shaderManager = new ShaderManager(gl);\n\n        /** @type {HTMLCanvasElement} */\n        this._tempCanvas = document.createElement('canvas');\n\n        /** @type {any} */\n        this._regionId = null;\n\n        /** @type {function} */\n        this._exitRegion = null;\n\n        /** @type {Array.<snapshotCallback>} */\n        this._snapshotCallbacks = [];\n\n        this._svgTextBubble = new SVGTextBubble();\n\n        this._createGeometry();\n\n        this.on(RenderConstants.Events.NativeSizeChanged, this.onNativeSizeChanged);\n\n        this.setBackgroundColor(1, 1, 1);\n        this.setStageSize(xLeft || -240, xRight || 240, yBottom || -180, yTop || 180);\n        this.resize(this._nativeSize[0], this._nativeSize[1]);\n\n        gl.disable(gl.DEPTH_TEST);\n        /** @todo disable when no partial transparency? */\n        gl.enable(gl.BLEND);\n        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE);\n    }\n\n    /**\n     * @returns {WebGLRenderingContext} the WebGL rendering context associated with this renderer.\n     */\n    get gl () {\n        return this._gl;\n    }\n\n    /**\n     * @returns {HTMLCanvasElement} the canvas of the WebGL rendering context associated with this renderer.\n     */\n    get canvas () {\n        return this._gl && this._gl.canvas;\n    }\n\n    /**\n     * Set the physical size of the stage in device-independent pixels.\n     * This will be multiplied by the device's pixel ratio on high-DPI displays.\n     * @param {int} pixelsWide The desired width in device-independent pixels.\n     * @param {int} pixelsTall The desired height in device-independent pixels.\n     */\n    resize (pixelsWide, pixelsTall) {\n        const pixelRatio = window.devicePixelRatio || 1;\n        this._gl.canvas.width = pixelsWide * pixelRatio;\n        this._gl.canvas.height = pixelsTall * pixelRatio;\n    }\n\n    /**\n     * Set the background color for the stage. The stage will be cleared with this\n     * color each frame.\n     * @param {number} red The red component for the background.\n     * @param {number} green The green component for the background.\n     * @param {number} blue The blue component for the background.\n     */\n    setBackgroundColor (red, green, blue) {\n        this._backgroundColor = [red, green, blue, 1];\n    }\n\n    /**\n     * Tell the renderer to draw various debug information to the provided canvas\n     * during certain operations.\n     * @param {canvas} canvas The canvas to use for debug output.\n     */\n    setDebugCanvas (canvas) {\n        this._debugCanvas = canvas;\n    }\n\n    /**\n     * Set logical size of the stage in Scratch units.\n     * @param {int} xLeft The left edge's x-coordinate. Scratch 2 uses -240.\n     * @param {int} xRight The right edge's x-coordinate. Scratch 2 uses 240.\n     * @param {int} yBottom The bottom edge's y-coordinate. Scratch 2 uses -180.\n     * @param {int} yTop The top edge's y-coordinate. Scratch 2 uses 180.\n     */\n    setStageSize (xLeft, xRight, yBottom, yTop) {\n        this._xLeft = xLeft;\n        this._xRight = xRight;\n        this._yBottom = yBottom;\n        this._yTop = yTop;\n\n        // swap yBottom & yTop to fit Scratch convention of +y=up\n        this._projection = twgl.m4.ortho(xLeft, xRight, yBottom, yTop, -1, 1);\n\n        this._setNativeSize(Math.abs(xRight - xLeft), Math.abs(yBottom - yTop));\n    }\n\n    /**\n     * @return {Array<int>} the \"native\" size of the stage, which is used for pen, query renders, etc.\n     */\n    getNativeSize () {\n        return [this._nativeSize[0], this._nativeSize[1]];\n    }\n\n    /**\n     * Set the \"native\" size of the stage, which is used for pen, query renders, etc.\n     * @param {int} width - the new width to set.\n     * @param {int} height - the new height to set.\n     * @private\n     * @fires RenderWebGL#event:NativeSizeChanged\n     */\n    _setNativeSize (width, height) {\n        this._nativeSize = [width, height];\n        this.emit(RenderConstants.Events.NativeSizeChanged, {newSize: this._nativeSize});\n    }\n\n    /**\n     * Create a new bitmap skin from a snapshot of the provided bitmap data.\n     * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} bitmapData - new contents for this skin.\n     * @param {!int} [costumeResolution=1] - The resolution to use for this bitmap.\n     * @param {?Array<number>} [rotationCenter] Optional: rotation center of the skin. If not supplied, the center of\n     * the skin will be used.\n     * @returns {!int} the ID for the new skin.\n     */\n    createBitmapSkin (bitmapData, costumeResolution, rotationCenter) {\n        const skinId = this._nextSkinId++;\n        const newSkin = new BitmapSkin(skinId, this);\n        newSkin.setBitmap(bitmapData, costumeResolution, rotationCenter);\n        this._allSkins[skinId] = newSkin;\n        return skinId;\n    }\n\n    /**\n     * Create a new SVG skin.\n     * @param {!string} svgData - new SVG to use.\n     * @param {?Array<number>} rotationCenter Optional: rotation center of the skin. If not supplied, the center of the\n     * skin will be used\n     * @returns {!int} the ID for the new skin.\n     */\n    createSVGSkin (svgData, rotationCenter) {\n        const skinId = this._nextSkinId++;\n        const newSkin = new SVGSkin(skinId, this);\n        newSkin.setSVG(svgData, rotationCenter);\n        this._allSkins[skinId] = newSkin;\n        return skinId;\n    }\n\n    /**\n     * Create a new PenSkin - a skin which implements a Scratch pen layer.\n     * @returns {!int} the ID for the new skin.\n     */\n    createPenSkin () {\n        const skinId = this._nextSkinId++;\n        const newSkin = new PenSkin(skinId, this);\n        this._allSkins[skinId] = newSkin;\n        return skinId;\n    }\n\n    /**\n     * Create a new SVG skin using the text bubble svg creator. The rotation center\n     * is always placed at the top left.\n     * @param {!string} type - either \"say\" or \"think\".\n     * @param {!string} text - the text for the bubble.\n     * @param {!boolean} pointsLeft - which side the bubble is pointing.\n     * @returns {!int} the ID for the new skin.\n     */\n    createTextSkin (type, text, pointsLeft) {\n        const bubbleSvg = this._svgTextBubble.buildString(type, text, pointsLeft);\n        return this.createSVGSkin(bubbleSvg, [0, 0]);\n    }\n\n    /**\n     * Update an existing SVG skin, or create an SVG skin if the previous skin was not SVG.\n     * @param {!int} skinId the ID for the skin to change.\n     * @param {!string} svgData - new SVG to use.\n     * @param {?Array<number>} rotationCenter Optional: rotation center of the skin. If not supplied, the center of the\n     * skin will be used\n     */\n    updateSVGSkin (skinId, svgData, rotationCenter) {\n        if (this._allSkins[skinId] instanceof SVGSkin) {\n            this._allSkins[skinId].setSVG(svgData, rotationCenter);\n            return;\n        }\n\n        const newSkin = new SVGSkin(skinId, this);\n        newSkin.setSVG(svgData, rotationCenter);\n        this._reskin(skinId, newSkin);\n    }\n\n    /**\n     * Update an existing bitmap skin, or create a bitmap skin if the previous skin was not bitmap.\n     * @param {!int} skinId the ID for the skin to change.\n     * @param {!ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imgData - new contents for this skin.\n     * @param {!number} bitmapResolution - the resolution scale for a bitmap costume.\n     * @param {?Array<number>} rotationCenter Optional: rotation center of the skin. If not supplied, the center of the\n     * skin will be used\n     */\n    updateBitmapSkin (skinId, imgData, bitmapResolution, rotationCenter) {\n        if (this._allSkins[skinId] instanceof BitmapSkin) {\n            this._allSkins[skinId].setBitmap(imgData, bitmapResolution, rotationCenter);\n            return;\n        }\n\n        const newSkin = new BitmapSkin(skinId, this);\n        newSkin.setBitmap(imgData, bitmapResolution, rotationCenter);\n        this._reskin(skinId, newSkin);\n    }\n\n    _reskin (skinId, newSkin) {\n        const oldSkin = this._allSkins[skinId];\n        this._allSkins[skinId] = newSkin;\n\n        // Tell drawables to update\n        for (const drawable of this._allDrawables) {\n            if (drawable && drawable.skin === oldSkin) {\n                drawable.skin = newSkin;\n                drawable.setConvexHullDirty();\n                drawable.setTransformDirty();\n            }\n        }\n        oldSkin.dispose();\n    }\n\n    /**\n     * Update a skin using the text bubble svg creator.\n     * @param {!int} skinId the ID for the skin to change.\n     * @param {!string} type - either \"say\" or \"think\".\n     * @param {!string} text - the text for the bubble.\n     * @param {!boolean} pointsLeft - which side the bubble is pointing.\n     */\n    updateTextSkin (skinId, type, text, pointsLeft) {\n        const bubbleSvg = this._svgTextBubble.buildString(type, text, pointsLeft);\n        this.updateSVGSkin(skinId, bubbleSvg, [0, 0]);\n    }\n\n\n    /**\n     * Destroy an existing skin. Do not use the skin or its ID after calling this.\n     * @param {!int} skinId - The ID of the skin to destroy.\n     */\n    destroySkin (skinId) {\n        const oldSkin = this._allSkins[skinId];\n        oldSkin.dispose();\n        delete this._allSkins[skinId];\n    }\n\n    /**\n     * Create a new Drawable and add it to the scene.\n     * @param {string} group Layer group to add the drawable to\n     * @returns {int} The ID of the new Drawable.\n     */\n    createDrawable (group) {\n        if (!group || !this._layerGroups.hasOwnProperty(group)) {\n            log.warn('Cannot create a drawable without a known layer group');\n            return;\n        }\n        const drawableID = this._nextDrawableId++;\n        const drawable = new Drawable(drawableID);\n        this._allDrawables[drawableID] = drawable;\n        this._addToDrawList(drawableID, group);\n\n        drawable.skin = null;\n\n        return drawableID;\n    }\n\n    /**\n     * Set the layer group ordering for the renderer.\n     * @param {Array<string>} groupOrdering The ordered array of layer group\n     * names\n     */\n    setLayerGroupOrdering (groupOrdering) {\n        this._groupOrdering = groupOrdering;\n        for (let i = 0; i < this._groupOrdering.length; i++) {\n            this._layerGroups[this._groupOrdering[i]] = {\n                groupIndex: i,\n                drawListOffset: 0\n            };\n        }\n    }\n\n    _addToDrawList (drawableID, group) {\n        const currentLayerGroup = this._layerGroups[group];\n        const currentGroupOrderingIndex = currentLayerGroup.groupIndex;\n\n        const drawListOffset = this._endIndexForKnownLayerGroup(currentLayerGroup);\n        this._drawList.splice(drawListOffset, 0, drawableID);\n\n        this._updateOffsets('add', currentGroupOrderingIndex);\n    }\n\n    _updateOffsets (updateType, currentGroupOrderingIndex) {\n        for (let i = currentGroupOrderingIndex + 1; i < this._groupOrdering.length; i++) {\n            const laterGroupName = this._groupOrdering[i];\n            if (updateType === 'add') {\n                this._layerGroups[laterGroupName].drawListOffset++;\n            } else if (updateType === 'delete'){\n                this._layerGroups[laterGroupName].drawListOffset--;\n            }\n        }\n    }\n\n    get _visibleDrawList () {\n        return this._drawList.filter(id => this._allDrawables[id]._visible);\n    }\n\n    // Given a layer group, return the index where it ends (non-inclusive),\n    // e.g. the returned index does not have a drawable from this layer group in it)\n    _endIndexForKnownLayerGroup (layerGroup) {\n        const groupIndex = layerGroup.groupIndex;\n        if (groupIndex === this._groupOrdering.length - 1) {\n            return this._drawList.length;\n        }\n        return this._layerGroups[this._groupOrdering[groupIndex + 1]].drawListOffset;\n    }\n\n    /**\n     * Destroy a Drawable, removing it from the scene.\n     * @param {int} drawableID The ID of the Drawable to remove.\n     * @param {string} group Group name that the drawable belongs to\n     */\n    destroyDrawable (drawableID, group) {\n        if (!group || !this._layerGroups.hasOwnProperty(group)) {\n            log.warn('Cannot destroy drawable without known layer group.');\n            return;\n        }\n        const drawable = this._allDrawables[drawableID];\n        drawable.dispose();\n        delete this._allDrawables[drawableID];\n\n        const currentLayerGroup = this._layerGroups[group];\n        const endIndex = this._endIndexForKnownLayerGroup(currentLayerGroup);\n\n        let index = currentLayerGroup.drawListOffset;\n        while (index < endIndex) {\n            if (this._drawList[index] === drawableID) {\n                break;\n            }\n            index++;\n        }\n        if (index < endIndex) {\n            this._drawList.splice(index, 1);\n            this._updateOffsets('delete', currentLayerGroup.groupIndex);\n        } else {\n            log.warn('Could not destroy drawable that could not be found in layer group.');\n            return;\n        }\n    }\n\n    /**\n     * Returns the position of the given drawableID in the draw list. This is\n     * the absolute position irrespective of layer group.\n     * @param {number} drawableID The drawable ID to find.\n     * @return {number} The postion of the given drawable ID.\n     */\n    getDrawableOrder (drawableID) {\n        return this._drawList.indexOf(drawableID);\n    }\n\n    /**\n     * Set a drawable's order in the drawable list (effectively, z/layer).\n     * Can be used to move drawables to absolute positions in the list,\n     * or relative to their current positions.\n     * \"go back N layers\": setDrawableOrder(id, -N, true, 1); (assuming stage at 0).\n     * \"go to back\": setDrawableOrder(id, 1); (assuming stage at 0).\n     * \"go to front\": setDrawableOrder(id, Infinity);\n     * @param {int} drawableID ID of Drawable to reorder.\n     * @param {number} order New absolute order or relative order adjusment.\n     * @param {string=} group Name of layer group drawable belongs to.\n     * Reordering will not take place if drawable cannot be found within the bounds\n     * of the layer group.\n     * @param {boolean=} optIsRelative If set, `order` refers to a relative change.\n     * @param {number=} optMin If set, order constrained to be at least `optMin`.\n     * @return {?number} New order if changed, or null.\n     */\n    setDrawableOrder (drawableID, order, group, optIsRelative, optMin) {\n        if (!group || !this._layerGroups.hasOwnProperty(group)) {\n            log.warn('Cannot set the order of a drawable without a known layer group.');\n            return;\n        }\n\n        const currentLayerGroup = this._layerGroups[group];\n        const startIndex = currentLayerGroup.drawListOffset;\n        const endIndex = this._endIndexForKnownLayerGroup(currentLayerGroup);\n\n        let oldIndex = startIndex;\n        while (oldIndex < endIndex) {\n            if (this._drawList[oldIndex] === drawableID) {\n                break;\n            }\n            oldIndex++;\n        }\n\n        if (oldIndex < endIndex) {\n            // Remove drawable from the list.\n            if (order === 0) {\n                return oldIndex;\n            }\n\n            const _ = this._drawList.splice(oldIndex, 1)[0];\n            // Determine new index.\n            let newIndex = order;\n            if (optIsRelative) {\n                newIndex += oldIndex;\n            }\n\n            const possibleMin = (optMin || 0) + startIndex;\n            const min = (possibleMin >= startIndex && possibleMin < endIndex) ? possibleMin : startIndex;\n            newIndex = Math.max(newIndex, min);\n\n            newIndex = Math.min(newIndex, endIndex);\n\n            // Insert at new index.\n            this._drawList.splice(newIndex, 0, drawableID);\n            return newIndex;\n        }\n\n        return null;\n    }\n\n    /**\n     * Draw all current drawables and present the frame on the canvas.\n     */\n    draw () {\n        this._doExitDrawRegion();\n\n        const gl = this._gl;\n\n        twgl.bindFramebufferInfo(gl, null);\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n        gl.clearColor.apply(gl, this._backgroundColor);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        this._drawThese(this._drawList, ShaderManager.DRAW_MODE.default, this._projection);\n        if (this._snapshotCallbacks.length > 0) {\n            const snapshot = gl.canvas.toDataURL();\n            this._snapshotCallbacks.forEach(cb => cb(snapshot));\n            this._snapshotCallbacks = [];\n        }\n    }\n\n    /**\n     * Get the precise bounds for a Drawable.\n     * @param {int} drawableID ID of Drawable to get bounds for.\n     * @return {object} Bounds for a tight box around the Drawable.\n     */\n    getBounds (drawableID) {\n        const drawable = this._allDrawables[drawableID];\n        // Tell the Drawable about its updated convex hull, if necessary.\n        if (drawable.needsConvexHullPoints()) {\n            const points = this._getConvexHullPointsForDrawable(drawableID);\n            drawable.setConvexHullPoints(points);\n        }\n        const bounds = drawable.getFastBounds();\n        // In debug mode, draw the bounds.\n        if (this._debugCanvas) {\n            const gl = this._gl;\n            this._debugCanvas.width = gl.canvas.width;\n            this._debugCanvas.height = gl.canvas.height;\n            const context = this._debugCanvas.getContext('2d');\n            context.drawImage(gl.canvas, 0, 0);\n            context.strokeStyle = '#FF0000';\n            const pr = window.devicePixelRatio;\n            context.strokeRect(\n                pr * (bounds.left + (this._nativeSize[0] / 2)),\n                pr * (-bounds.top + (this._nativeSize[1] / 2)),\n                pr * (bounds.right - bounds.left),\n                pr * (-bounds.bottom + bounds.top)\n            );\n        }\n        return bounds;\n    }\n\n    /**\n     * Get the precise bounds for a Drawable around the top slice.\n     * Used for positioning speech bubbles more closely to the sprite.\n     * @param {int} drawableID ID of Drawable to get bubble bounds for.\n     * @return {object} Bounds for a tight box around the Drawable top slice.\n     */\n    getBoundsForBubble (drawableID) {\n        const drawable = this._allDrawables[drawableID];\n        // Tell the Drawable about its updated convex hull, if necessary.\n        if (drawable.needsConvexHullPoints()) {\n            const points = this._getConvexHullPointsForDrawable(drawableID);\n            drawable.setConvexHullPoints(points);\n        }\n        const bounds = drawable.getBoundsForBubble();\n        // In debug mode, draw the bounds.\n        if (this._debugCanvas) {\n            const gl = this._gl;\n            this._debugCanvas.width = gl.canvas.width;\n            this._debugCanvas.height = gl.canvas.height;\n            const context = this._debugCanvas.getContext('2d');\n            context.drawImage(gl.canvas, 0, 0);\n            context.strokeStyle = '#FF0000';\n            const pr = window.devicePixelRatio;\n            context.strokeRect(\n                pr * (bounds.left + (this._nativeSize[0] / 2)),\n                pr * (-bounds.top + (this._nativeSize[1] / 2)),\n                pr * (bounds.right - bounds.left),\n                pr * (-bounds.bottom + bounds.top)\n            );\n        }\n        return bounds;\n    }\n\n    /**\n     * Get the current skin (costume) size of a Drawable.\n     * @param {int} drawableID The ID of the Drawable to measure.\n     * @return {Array<number>} Skin size, width and height.\n     */\n    getCurrentSkinSize (drawableID) {\n        const drawable = this._allDrawables[drawableID];\n        return this.getSkinSize(drawable.skin.id);\n    }\n\n    /**\n     * Get the size of a skin by ID.\n     * @param {int} skinID The ID of the Skin to measure.\n     * @return {Array<number>} Skin size, width and height.\n     */\n    getSkinSize (skinID) {\n        const skin = this._allSkins[skinID];\n        return skin.size;\n    }\n\n    /**\n     * Get the rotation center of a skin by ID.\n     * @param {int} skinID The ID of the Skin\n     * @return {Array<number>} The rotationCenterX and rotationCenterY\n     */\n    getSkinRotationCenter (skinID) {\n        const skin = this._allSkins[skinID];\n        return skin.calculateRotationCenter();\n    }\n\n    /**\n     * Check if a particular Drawable is touching a particular color.\n     * Unlike touching drawable, if the \"tester\" is invisble, we will still test.\n     * @param {int} drawableID The ID of the Drawable to check.\n     * @param {Array<int>} color3b Test if the Drawable is touching this color.\n     * @param {Array<int>} [mask3b] Optionally mask the check to this part of Drawable.\n     * @returns {boolean} True iff the Drawable is touching the color.\n     */\n    isTouchingColor (drawableID, color3b, mask3b) {\n        const candidates = this._candidatesTouching(drawableID, this._visibleDrawList);\n        if (candidates.length === 0) {\n            return false;\n        }\n\n        const bounds = this._candidatesBounds(candidates);\n\n        // if there are just too many pixels to CPU render efficently, we\n        // need to let readPixels happen\n        if (bounds.width * bounds.height * (candidates.length + 1) >= __cpuTouchingColorPixelCount) {\n            this._isTouchingColorGpuStart(drawableID, candidates.map(({id}) => id).reverse(), bounds, color3b, mask3b);\n        }\n\n        const drawable = this._allDrawables[drawableID];\n        const point = __isTouchingDrawablesPoint;\n        const color = __touchingColor;\n        const hasMask = Boolean(mask3b);\n\n        for (let y = bounds.bottom; y <= bounds.top; y++) {\n            if (bounds.width * (y - bounds.bottom) * (candidates.length + 1) >= __cpuTouchingColorPixelCount) {\n                return this._isTouchingColorGpuFin(bounds, color3b, y - bounds.bottom);\n            }\n            // Scratch Space - +y is top\n            for (let x = bounds.left; x <= bounds.right; x++) {\n                point[1] = y;\n                point[0] = x;\n                if (\n                    // if we use a mask, check our sample color\n                    (hasMask ?\n                        maskMatches(Drawable.sampleColor4b(point, drawable, color), mask3b) :\n                        drawable.isTouching(point)) &&\n                    // and the target color is drawn at this pixel\n                    colorMatches(RenderWebGL.sampleColor3b(point, candidates, color), color3b, 0)\n                ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    _isTouchingColorGpuStart (drawableID, candidateIDs, bounds, color3b, mask3b) {\n        this._doExitDrawRegion();\n\n        const gl = this._gl;\n        twgl.bindFramebufferInfo(gl, this._queryBufferInfo);\n\n        // Limit size of viewport to the bounds around the target Drawable,\n        // and create the projection matrix for the draw.\n        gl.viewport(0, 0, bounds.width, bounds.height);\n        const projection = twgl.m4.ortho(bounds.left, bounds.right, bounds.top, bounds.bottom, -1, 1);\n\n        let fillBackgroundColor = this._backgroundColor;\n\n        // When using masking such that the background fill color will showing through, ensure we don't\n        // fill using the same color that we are trying to detect!\n        if (color3b[0] > 196 && color3b[1] > 196 && color3b[2] > 196) {\n            fillBackgroundColor = [0, 0, 0, 255];\n        }\n\n        gl.clearColor.apply(gl, fillBackgroundColor);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n\n        let extraUniforms;\n        if (mask3b) {\n            extraUniforms = {\n                u_colorMask: [mask3b[0] / 255, mask3b[1] / 255, mask3b[2] / 255],\n                u_colorMaskTolerance: MASK_TOUCHING_COLOR_TOLERANCE / 255\n            };\n        }\n\n        try {\n            gl.enable(gl.STENCIL_TEST);\n            gl.stencilFunc(gl.ALWAYS, 1, 1);\n            gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\n            gl.colorMask(false, false, false, false);\n            this._drawThese(\n                [drawableID],\n                mask3b ?\n                    ShaderManager.DRAW_MODE.colorMask :\n                    ShaderManager.DRAW_MODE.silhouette,\n                projection,\n                {\n                    extraUniforms,\n                    ignoreVisibility: true // Touching color ignores sprite visibility\n                });\n\n            gl.stencilFunc(gl.EQUAL, 1, 1);\n            gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n            gl.colorMask(true, true, true, true);\n\n            this._drawThese(candidateIDs, ShaderManager.DRAW_MODE.default, projection,\n                {idFilterFunc: testID => testID !== drawableID}\n            );\n        } finally {\n            gl.colorMask(true, true, true, true);\n            gl.disable(gl.STENCIL_TEST);\n        }\n    }\n\n    _isTouchingColorGpuFin (bounds, color3b, stop) {\n        const gl = this._gl;\n        const pixels = new Uint8Array(Math.floor(bounds.width * (bounds.height - stop) * 4));\n        gl.readPixels(0, 0, bounds.width, (bounds.height - stop), gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n\n        if (this._debugCanvas) {\n            this._debugCanvas.width = bounds.width;\n            this._debugCanvas.height = bounds.height;\n            const context = this._debugCanvas.getContext('2d');\n            const imageData = context.getImageData(0, 0, bounds.width, bounds.height - stop);\n            imageData.data.set(pixels);\n            context.putImageData(imageData, 0, 0);\n        }\n\n        for (let pixelBase = 0; pixelBase < pixels.length; pixelBase += 4) {\n            if (colorMatches(color3b, pixels, pixelBase)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if a particular Drawable is touching any in a set of Drawables.\n     * @param {int} drawableID The ID of the Drawable to check.\n     * @param {?Array<int>} candidateIDs The Drawable IDs to check, otherwise all visible drawables in the renderer\n     * @returns {boolean} True if the Drawable is touching one of candidateIDs.\n     */\n    isTouchingDrawables (drawableID, candidateIDs = this._drawList) {\n        const candidates = this._candidatesTouching(drawableID,\n            // even if passed an invisible drawable, we will NEVER touch it!\n            candidateIDs.filter(id => this._allDrawables[id]._visible));\n        // if we are invisble we don't touch anything.\n        if (candidates.length === 0 || !this._allDrawables[drawableID]._visible) {\n            return false;\n        }\n\n        // Get the union of all the candidates intersections.\n        const bounds = this._candidatesBounds(candidates);\n\n        const drawable = this._allDrawables[drawableID];\n        const point = __isTouchingDrawablesPoint;\n\n        // This is an EXTREMELY brute force collision detector, but it is\n        // still faster than asking the GPU to give us the pixels.\n        for (let x = bounds.left; x <= bounds.right; x++) {\n            // Scratch Space - +y is top\n            point[0] = x;\n            for (let y = bounds.bottom; y <= bounds.top; y++) {\n                point[1] = y;\n                if (drawable.isTouching(point)) {\n                    for (let index = 0; index < candidates.length; index++) {\n                        if (candidates[index].drawable.isTouching(point)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Convert a client based x/y position on the canvas to a Scratch 3 world space\n     * Rectangle.  This creates recangles with a radius to cover selecting multiple\n     * scratch pixels with touch / small render areas.\n     *\n     * @param {int} centerX The client x coordinate of the picking location.\n     * @param {int} centerY The client y coordinate of the picking location.\n     * @param {int} [width] The client width of the touch event (optional).\n     * @param {int} [height] The client width of the touch event (optional).\n     * @returns {Rectangle} Scratch world space rectangle, iterate bottom <= top,\n     *                      left <= right.\n     */\n    clientSpaceToScratchBounds (centerX, centerY, width = 1, height = 1) {\n        const gl = this._gl;\n\n        const clientToScratchX = this._nativeSize[0] / gl.canvas.clientWidth;\n        const clientToScratchY = this._nativeSize[1] / gl.canvas.clientHeight;\n\n        width *= clientToScratchX;\n        height *= clientToScratchY;\n\n        width = Math.max(1, Math.min(Math.round(width), MAX_TOUCH_SIZE[0]));\n        height = Math.max(1, Math.min(Math.round(height), MAX_TOUCH_SIZE[1]));\n        const x = (centerX * clientToScratchX) - ((width - 1) / 2);\n        // + because scratch y is inverted\n        const y = (centerY * clientToScratchY) + ((height - 1) / 2);\n\n        const xOfs = (width % 2) ? 0 : -0.5;\n        // y is offset +0.5\n        const yOfs = (height % 2) ? 0 : -0.5;\n\n        const bounds = new Rectangle();\n        bounds.initFromBounds(Math.floor(this._xLeft + x + xOfs), Math.floor(this._xLeft + x + xOfs + width - 1),\n            Math.ceil(this._yTop - y + yOfs), Math.ceil(this._yTop - y + yOfs + height - 1));\n        return bounds;\n    }\n\n    /**\n     * Determine if the drawable is touching a client based x/y.  Helper method for sensing\n     * touching mouse-pointer.  Ignores visibility.\n     *\n     * @param {int} drawableID The ID of the drawable to check.\n     * @param {int} centerX The client x coordinate of the picking location.\n     * @param {int} centerY The client y coordinate of the picking location.\n     * @param {int} [touchWidth] The client width of the touch event (optional).\n     * @param {int} [touchHeight] The client height of the touch event (optional).\n     * @returns {boolean} If the drawable has any pixels that would draw in the touch area\n     */\n    drawableTouching (drawableID, centerX, centerY, touchWidth, touchHeight) {\n        const drawable = this._allDrawables[drawableID];\n        if (!drawable) {\n            return false;\n        }\n        const bounds = this.clientSpaceToScratchBounds(centerX, centerY, touchWidth, touchHeight);\n        const worldPos = twgl.v3.create();\n\n        drawable.updateMatrix();\n        drawable.skin.updateSilhouette();\n\n        for (worldPos[1] = bounds.bottom; worldPos[1] <= bounds.top; worldPos[1]++) {\n            for (worldPos[0] = bounds.left; worldPos[0] <= bounds.right; worldPos[0]++) {\n                if (drawable.isTouching(worldPos)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Detect which sprite, if any, is at the given location.\n     * This function will pick all drawables that are visible, unless specific\n     * candidate drawable IDs are provided.  Used for determining what is clicked\n     * or dragged.  Will not select hidden / ghosted sprites.\n     *\n     * @param {int} centerX The client x coordinate of the picking location.\n     * @param {int} centerY The client y coordinate of the picking location.\n     * @param {int} [touchWidth] The client width of the touch event (optional).\n     * @param {int} [touchHeight] The client height of the touch event (optional).\n     * @param {Array<int>} [candidateIDs] The Drawable IDs to pick from, otherwise all visible drawables.\n     * @returns {int} The ID of the topmost Drawable under the picking location, or\n     * RenderConstants.ID_NONE if there is no Drawable at that location.\n     */\n    pick (centerX, centerY, touchWidth, touchHeight, candidateIDs) {\n        candidateIDs = (candidateIDs || this._drawList).filter(id => {\n            const drawable = this._allDrawables[id];\n            // default pick list ignores visible and ghosted sprites.\n            if (drawable.getVisible() && drawable.getUniforms().u_ghost !== 0) {\n                drawable.updateMatrix();\n                drawable.skin.updateSilhouette();\n                return true;\n            }\n            return false;\n        });\n        if (candidateIDs.length === 0) {\n            return false;\n        }\n\n        const bounds = this.clientSpaceToScratchBounds(centerX, centerY, touchWidth, touchHeight);\n        if (bounds.left === -Infinity || bounds.bottom === -Infinity) {\n            return false;\n        }\n\n        const hits = [];\n        const worldPos = twgl.v3.create(0, 0, 0);\n        // Iterate over the scratch pixels and check if any candidate can be\n        // touched at that point.\n        for (worldPos[1] = bounds.bottom; worldPos[1] <= bounds.top; worldPos[1]++) {\n            for (worldPos[0] = bounds.left; worldPos[0] <= bounds.right; worldPos[0]++) {\n\n                // Check candidates in the reverse order they would have been\n                // drawn. This will determine what candiate's silhouette pixel\n                // would have been drawn at the point.\n                for (let d = candidateIDs.length - 1; d >= 0; d--) {\n                    const id = candidateIDs[d];\n                    const drawable = this._allDrawables[id];\n                    if (drawable.isTouching(worldPos)) {\n                        hits[id] = (hits[id] || 0) + 1;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // Bias toward selecting anything over nothing\n        hits[RenderConstants.ID_NONE] = 0;\n\n        let hit = RenderConstants.ID_NONE;\n        for (const hitID in hits) {\n            if (hits.hasOwnProperty(hitID) && (hits[hitID] > hits[hit])) {\n                hit = hitID;\n            }\n        }\n\n        return Number(hit);\n    }\n\n    /**\n     * @typedef DrawableExtraction\n     * @property {Uint8Array} data Raw pixel data for the drawable\n     * @property {int} width Drawable bounding box width\n     * @property {int} height Drawable bounding box height\n     * @property {Array<number>} scratchOffset [x, y] offset in Scratch coordinates\n     * from the drawable position to the client x, y coordinate\n     * @property {int} x The x coordinate relative to drawable bounding box\n     * @property {int} y The y coordinate relative to drawable bounding box\n     */\n\n    /**\n     * Return drawable pixel data and picking coordinates relative to the drawable bounds\n     * @param {int} drawableID The ID of the drawable to get pixel data for\n     * @param {int} x The client x coordinate of the picking location.\n     * @param {int} y The client y coordinate of the picking location.\n     * @return {?DrawableExtraction} Data about the picked drawable\n     */\n    extractDrawable (drawableID, x, y) {\n        this._doExitDrawRegion();\n\n        const drawable = this._allDrawables[drawableID];\n        if (!drawable) return null;\n\n        // Convert client coordinates into absolute scratch units\n        const scratchX = this._nativeSize[0] * ((x / this._gl.canvas.clientWidth) - 0.5);\n        const scratchY = this._nativeSize[1] * ((y / this._gl.canvas.clientHeight) - 0.5);\n\n        const gl = this._gl;\n        twgl.bindFramebufferInfo(gl, this._queryBufferInfo);\n\n        const bounds = drawable.getFastBounds();\n        bounds.snapToInt();\n\n        // Translate to scratch units relative to the drawable\n        const pickX = scratchX - bounds.left;\n        const pickY = scratchY + bounds.top;\n\n        // Limit size of viewport to the bounds around the target Drawable,\n        // and create the projection matrix for the draw.\n        gl.viewport(0, 0, bounds.width, bounds.height);\n        const projection = twgl.m4.ortho(bounds.left, bounds.right, bounds.top, bounds.bottom, -1, 1);\n\n        gl.clearColor(0, 0, 0, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        try {\n            gl.disable(gl.BLEND);\n            this._drawThese([drawableID], ShaderManager.DRAW_MODE.default, projection,\n                {effectMask: ~ShaderManager.EFFECT_INFO.ghost.mask});\n        } finally {\n            gl.enable(gl.BLEND);\n        }\n\n        const data = new Uint8Array(Math.floor(bounds.width * bounds.height * 4));\n        gl.readPixels(0, 0, bounds.width, bounds.height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n\n        if (this._debugCanvas) {\n            this._debugCanvas.width = bounds.width;\n            this._debugCanvas.height = bounds.height;\n            const ctx = this._debugCanvas.getContext('2d');\n            const imageData = ctx.createImageData(bounds.width, bounds.height);\n            imageData.data.set(data);\n            ctx.putImageData(imageData, 0, 0);\n            ctx.beginPath();\n            ctx.arc(pickX, pickY, 3, 0, 2 * Math.PI, false);\n            ctx.fillStyle = 'white';\n            ctx.fill();\n            ctx.lineWidth = 1;\n            ctx.strokeStyle = 'black';\n            ctx.stroke();\n        }\n\n        return {\n            data: data,\n            width: bounds.width,\n            height: bounds.height,\n            scratchOffset: [\n                -scratchX + drawable._position[0],\n                -scratchY - drawable._position[1]\n            ],\n            x: pickX,\n            y: pickY\n        };\n    }\n\n    /**\n     * @typedef ColorExtraction\n     * @property {Uint8Array} data Raw pixel data for the drawable\n     * @property {int} width Drawable bounding box width\n     * @property {int} height Drawable bounding box height\n     * @property {object} color Color object with RGBA properties at picked location\n     */\n\n    /**\n     * Return drawable pixel data and color at a given position\n     * @param {int} x The client x coordinate of the picking location.\n     * @param {int} y The client y coordinate of the picking location.\n     * @param {int} radius The client radius to extract pixels with.\n     * @return {?ColorExtraction} Data about the picked color\n     */\n    extractColor (x, y, radius) {\n        this._doExitDrawRegion();\n\n        const scratchX = Math.round(this._nativeSize[0] * ((x / this._gl.canvas.clientWidth) - 0.5));\n        const scratchY = Math.round(-this._nativeSize[1] * ((y / this._gl.canvas.clientHeight) - 0.5));\n\n        const gl = this._gl;\n        twgl.bindFramebufferInfo(gl, this._queryBufferInfo);\n\n        const bounds = new Rectangle();\n        bounds.initFromBounds(scratchX - radius, scratchX + radius, scratchY - radius, scratchY + radius);\n\n        const pickX = scratchX - bounds.left;\n        const pickY = bounds.top - scratchY;\n\n        gl.viewport(0, 0, bounds.width, bounds.height);\n        const projection = twgl.m4.ortho(bounds.left, bounds.right, bounds.top, bounds.bottom, -1, 1);\n\n        gl.clearColor.apply(gl, this._backgroundColor);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        this._drawThese(this._drawList, ShaderManager.DRAW_MODE.default, projection);\n\n        const data = new Uint8Array(Math.floor(bounds.width * bounds.height * 4));\n        gl.readPixels(0, 0, bounds.width, bounds.height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n\n        const pixelBase = Math.floor(4 * ((pickY * bounds.width) + pickX));\n        const color = {\n            r: data[pixelBase],\n            g: data[pixelBase + 1],\n            b: data[pixelBase + 2],\n            a: data[pixelBase + 3]\n        };\n\n        if (this._debugCanvas) {\n            this._debugCanvas.width = bounds.width;\n            this._debugCanvas.height = bounds.height;\n            const ctx = this._debugCanvas.getContext('2d');\n            const imageData = ctx.createImageData(bounds.width, bounds.height);\n            imageData.data.set(data);\n            ctx.putImageData(imageData, 0, 0);\n            ctx.strokeStyle = 'black';\n            ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;\n            ctx.rect(pickX - 4, pickY - 4, 8, 8);\n            ctx.fill();\n            ctx.stroke();\n        }\n\n        return {\n            data: data,\n            width: bounds.width,\n            height: bounds.height,\n            color: color\n        };\n    }\n\n    /**\n     * Get the candidate bounding box for a touching query.\n     * @param {int} drawableID ID for drawable of query.\n     * @return {?Rectangle} Rectangle bounds for touching query, or null.\n     */\n    _touchingBounds (drawableID) {\n        const drawable = this._allDrawables[drawableID];\n\n        /** @todo remove this once URL-based skin setting is removed. */\n        if (!drawable.skin || !drawable.skin.getTexture([100, 100])) return null;\n\n        drawable.updateMatrix();\n        drawable.skin.updateSilhouette();\n        const bounds = drawable.getFastBounds();\n\n        // Limit queries to the stage size.\n        bounds.clamp(this._xLeft, this._xRight, this._yBottom, this._yTop);\n\n        // Use integer coordinates for queries - weird things happen\n        // when you provide float width/heights to gl.viewport and projection.\n        bounds.snapToInt();\n\n        if (bounds.width === 0 || bounds.height === 0) {\n            // No space to query.\n            return null;\n        }\n        return bounds;\n    }\n\n    /**\n     * Filter a list of candidates for a touching query into only those that\n     * could possibly intersect the given bounds.\n     * @param {int} drawableID - ID for drawable of query.\n     * @param {Array<int>} candidateIDs - Candidates for touching query.\n     * @return {?Array< {id, drawable, intersection} >} Filtered candidates with useful data.\n     */\n    _candidatesTouching (drawableID, candidateIDs) {\n        const bounds = this._touchingBounds(drawableID);\n        const result = [];\n        if (bounds === null) {\n            return result;\n        }\n        // iterate through the drawables list BACKWARDS - we want the top most item to be the first we check\n        for (let index = candidateIDs.length - 1; index >= 0; index--) {\n            const id = candidateIDs[index];\n            if (id !== drawableID) {\n                const drawable = this._allDrawables[id];\n                if (drawable.skin && drawable._visible) {\n                    // Update the CPU position data\n                    drawable.updateMatrix();\n                    drawable.skin.updateSilhouette();\n                    const candidateBounds = drawable.getFastBounds();\n                    if (bounds.intersects(candidateBounds)) {\n                        result.push({\n                            id,\n                            drawable,\n                            intersection: Rectangle.intersect(bounds, candidateBounds)\n                        });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Helper to get the union bounds from a set of candidates returned from the above method\n     * @private\n     * @param {Array<object>} candidates info from _candidatesTouching\n     * @return {Rectangle} the outer bounding box union\n     */\n    _candidatesBounds (candidates) {\n        return candidates.reduce((memo, {intersection}) => {\n            if (!memo) {\n                return intersection;\n            }\n            // store the union of the two rectangles in our static rectangle instance\n            return Rectangle.union(memo, intersection, __candidatesBounds);\n        }, null);\n    }\n\n\n    /**\n     * Update the position, direction, scale, or effect properties of this Drawable.\n     * @param {int} drawableID The ID of the Drawable to update.\n     * @param {object.<string,*>} properties The new property values to set.\n     */\n    updateDrawableProperties (drawableID, properties) {\n        const drawable = this._allDrawables[drawableID];\n        if (!drawable) {\n            /**\n             * @todo fix whatever's wrong in the VM which causes this, then add a warning or throw here.\n             * Right now this happens so much on some projects that a warning or exception here can hang the browser.\n             */\n            return;\n        }\n        if ('skinId' in properties) {\n            drawable.skin = this._allSkins[properties.skinId];\n        }\n        if ('rotationCenter' in properties) {\n            const newRotationCenter = properties.rotationCenter;\n            drawable.skin.setRotationCenter(newRotationCenter[0], newRotationCenter[1]);\n        }\n        drawable.updateProperties(properties);\n    }\n\n    /**\n     * Update the position object's x & y members to keep the drawable fenced in view.\n     * @param {int} drawableID - The ID of the Drawable to update.\n     * @param {Array.<number, number>} position to be fenced - An array of type [x, y]\n     * @return {Array.<number, number>} The fenced position as an array [x, y]\n     */\n    getFencedPositionOfDrawable (drawableID, position) {\n        let x = position[0];\n        let y = position[1];\n\n        const drawable = this._allDrawables[drawableID];\n        if (!drawable) {\n            // TODO: fix whatever's wrong in the VM which causes this, then add a warning or throw here.\n            // Right now this happens so much on some projects that a warning or exception here can hang the browser.\n            return [x, y];\n        }\n\n        const dx = x - drawable._position[0];\n        const dy = y - drawable._position[1];\n\n        const aabb = drawable.getFastBounds();\n\n        const sx = this._xRight - Math.min(FENCE_WIDTH, Math.floor((aabb.right - aabb.left) / 2));\n        if (aabb.right + dx < -sx) {\n            x = drawable._position[0] - (sx + aabb.right);\n        } else if (aabb.left + dx > sx) {\n            x = drawable._position[0] + (sx - aabb.left);\n        }\n        const sy = this._yTop - Math.min(FENCE_WIDTH, Math.floor((aabb.top - aabb.bottom) / 2));\n        if (aabb.top + dy < -sy) {\n            y = drawable._position[1] - (sy + aabb.top);\n        } else if (aabb.bottom + dy > sy) {\n            y = drawable._position[1] + (sy - aabb.bottom);\n        }\n        return [x, y];\n    }\n\n    /**\n     * Clear a pen layer.\n     * @param {int} penSkinID - the unique ID of a Pen Skin.\n     */\n    penClear (penSkinID) {\n        const skin = /** @type {PenSkin} */ this._allSkins[penSkinID];\n        skin.clear();\n    }\n\n    /**\n     * Draw a point on a pen layer.\n     * @param {int} penSkinID - the unique ID of a Pen Skin.\n     * @param {PenAttributes} penAttributes - how the point should be drawn.\n     * @param {number} x - the X coordinate of the point to draw.\n     * @param {number} y - the Y coordinate of the point to draw.\n     */\n    penPoint (penSkinID, penAttributes, x, y) {\n        const skin = /** @type {PenSkin} */ this._allSkins[penSkinID];\n        skin.drawPoint(penAttributes, x, y);\n    }\n\n    /**\n     * Draw a line on a pen layer.\n     * @param {int} penSkinID - the unique ID of a Pen Skin.\n     * @param {PenAttributes} penAttributes - how the line should be drawn.\n     * @param {number} x0 - the X coordinate of the beginning of the line.\n     * @param {number} y0 - the Y coordinate of the beginning of the line.\n     * @param {number} x1 - the X coordinate of the end of the line.\n     * @param {number} y1 - the Y coordinate of the end of the line.\n     */\n    penLine (penSkinID, penAttributes, x0, y0, x1, y1) {\n        const skin = /** @type {PenSkin} */ this._allSkins[penSkinID];\n        skin.drawLine(penAttributes, x0, y0, x1, y1);\n    }\n\n    /**\n     * Stamp a Drawable onto a pen layer.\n     * @param {int} penSkinID - the unique ID of a Pen Skin.\n     * @param {int} stampID - the unique ID of the Drawable to use as the stamp.\n     */\n    penStamp (penSkinID, stampID) {\n        this._doExitDrawRegion();\n\n        const stampDrawable = this._allDrawables[stampID];\n        if (!stampDrawable) {\n            return;\n        }\n\n        const bounds = this._touchingBounds(stampID);\n        if (!bounds) {\n            return;\n        }\n\n        const skin = /** @type {PenSkin} */ this._allSkins[penSkinID];\n\n        const gl = this._gl;\n        twgl.bindFramebufferInfo(gl, this._queryBufferInfo);\n\n        // Limit size of viewport to the bounds around the stamp Drawable and create the projection matrix for the draw.\n        gl.viewport(0, 0, bounds.width, bounds.height);\n        const projection = twgl.m4.ortho(bounds.left, bounds.right, bounds.top, bounds.bottom, -1, 1);\n\n        gl.clearColor(0, 0, 0, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        try {\n            gl.disable(gl.BLEND);\n            this._drawThese([stampID], ShaderManager.DRAW_MODE.stamp, projection, {ignoreVisibility: true});\n        } finally {\n            gl.enable(gl.BLEND);\n        }\n\n        skin._drawToBuffer(this._queryBufferInfo.attachments[0], bounds.left, bounds.top);\n    }\n\n    /* ******\n     * Truly internal functions: these support the functions above.\n     ********/\n\n    /**\n     * Build geometry (vertex and index) buffers.\n     * @private\n     */\n    _createGeometry () {\n        const quad = {\n            a_position: {\n                numComponents: 2,\n                data: [\n                    -0.5, -0.5,\n                    0.5, -0.5,\n                    -0.5, 0.5,\n                    -0.5, 0.5,\n                    0.5, -0.5,\n                    0.5, 0.5\n                ]\n            },\n            a_texCoord: {\n                numComponents: 2,\n                data: [\n                    1, 0,\n                    0, 0,\n                    1, 1,\n                    1, 1,\n                    0, 0,\n                    0, 1\n                ]\n            }\n        };\n        this._bufferInfo = twgl.createBufferInfoFromArrays(this._gl, quad);\n    }\n\n    /**\n     * Respond to a change in the \"native\" rendering size. The native size is used by buffers which are fixed in size\n     * regardless of the size of the main render target. This includes the buffers used for queries such as picking and\n     * color-touching. The fixed size allows (more) consistent behavior across devices and presentation modes.\n     * @param {object} event - The change event.\n     * @private\n     */\n    onNativeSizeChanged (event) {\n        const [width, height] = event.newSize;\n\n        const gl = this._gl;\n        const attachments = [\n            {format: gl.RGBA},\n            {format: gl.DEPTH_STENCIL}\n        ];\n\n        if (!this._pickBufferInfo) {\n            this._pickBufferInfo = twgl.createFramebufferInfo(gl, attachments, MAX_TOUCH_SIZE[0], MAX_TOUCH_SIZE[1]);\n        }\n\n        /** @todo should we create this on demand to save memory? */\n        // A 480x360 32-bpp buffer is 675 KiB.\n        if (this._queryBufferInfo) {\n            twgl.resizeFramebufferInfo(gl, this._queryBufferInfo, attachments, width, height);\n        } else {\n            this._queryBufferInfo = twgl.createFramebufferInfo(gl, attachments, width, height);\n        }\n    }\n\n    /**\n     * Enter a draw region.\n     *\n     * A draw region is where multiple draw operations are performed with the\n     * same GL state. WebGL performs poorly when it changes state like blend\n     * mode. Marking a collection of state values as a \"region\" the renderer\n     * can skip superfluous extra state calls when it is already in that\n     * region. Since one region may be entered from within another a exit\n     * handle can also be registered that is called when a new region is about\n     * to be entered to restore a common inbetween state.\n     *\n     * @param {any} regionId - id of the region to enter\n     * @param {function} enter - handle to call when first entering a region\n     * @param {function} exit - handle to call when leaving a region\n     */\n    enterDrawRegion (regionId, enter = regionId.enter, exit = regionId.exit) {\n        if (this._regionId !== regionId) {\n            this._doExitDrawRegion();\n            this._regionId = regionId;\n            enter();\n            this._exitRegion = exit;\n        }\n    }\n\n    /**\n     * Forcefully exit the current region returning to a common inbetween GL\n     * state.\n     */\n    _doExitDrawRegion () {\n        if (this._exitRegion !== null) {\n            this._exitRegion();\n        }\n        this._exitRegion = null;\n    }\n\n    /**\n     * Draw a set of Drawables, by drawable ID\n     * @param {Array<int>} drawables The Drawable IDs to draw, possibly this._drawList.\n     * @param {ShaderManager.DRAW_MODE} drawMode Draw normally, silhouette, etc.\n     * @param {module:twgl/m4.Mat4} projection The projection matrix to use.\n     * @param {object} [opts] Options for drawing\n     * @param {idFilterFunc} opts.filter An optional filter function.\n     * @param {object.<string,*>} opts.extraUniforms Extra uniforms for the shaders.\n     * @param {int} opts.effectMask Bitmask for effects to allow\n     * @param {boolean} opts.ignoreVisibility Draw all, despite visibility (e.g. stamping, touching color)\n     * @private\n     */\n    _drawThese (drawables, drawMode, projection, opts = {}) {\n\n        const gl = this._gl;\n        let currentShader = null;\n\n        const numDrawables = drawables.length;\n        for (let drawableIndex = 0; drawableIndex < numDrawables; ++drawableIndex) {\n            const drawableID = drawables[drawableIndex];\n\n            // If we have a filter, check whether the ID fails\n            if (opts.filter && !opts.filter(drawableID)) continue;\n\n            const drawable = this._allDrawables[drawableID];\n            /** @todo check if drawable is inside the viewport before anything else */\n\n            // Hidden drawables (e.g., by a \"hide\" block) are not drawn unless\n            // the ignoreVisibility flag is used (e.g. for stamping or touchingColor).\n            if (!drawable.getVisible() && !opts.ignoreVisibility) continue;\n\n            // Combine drawable scale with the native vs. backing pixel ratio\n            const drawableScale = [\n                drawable.scale[0] * this._gl.canvas.width / this._nativeSize[0],\n                drawable.scale[1] * this._gl.canvas.height / this._nativeSize[1]\n            ];\n\n            // If the skin or texture isn't ready yet, skip it.\n            if (!drawable.skin || !drawable.skin.getTexture(drawableScale)) continue;\n\n            const uniforms = {};\n\n            let effectBits = drawable.getEnabledEffects();\n            effectBits &= opts.hasOwnProperty('effectMask') ? opts.effectMask : effectBits;\n            const newShader = this._shaderManager.getShader(drawMode, effectBits);\n\n            // Manually perform region check. Do not create functions inside a\n            // loop.\n            if (this._regionId !== newShader) {\n                this._doExitDrawRegion();\n                this._regionId = newShader;\n\n                currentShader = newShader;\n                gl.useProgram(currentShader.program);\n                twgl.setBuffersAndAttributes(gl, currentShader, this._bufferInfo);\n                Object.assign(uniforms, {\n                    u_projectionMatrix: projection,\n                    u_fudge: window.fudge || 0\n                });\n            }\n\n            Object.assign(uniforms,\n                drawable.skin.getUniforms(drawableScale),\n                drawable.getUniforms());\n\n            // Apply extra uniforms after the Drawable's, to allow overwriting.\n            if (opts.extraUniforms) {\n                Object.assign(uniforms, opts.extraUniforms);\n            }\n\n            if (uniforms.u_skin) {\n                twgl.setTextureParameters(\n                    gl, uniforms.u_skin, {minMag: drawable.useNearest ? gl.NEAREST : gl.LINEAR}\n                );\n            }\n\n            twgl.setUniforms(currentShader, uniforms);\n\n            twgl.drawBufferInfo(gl, this._bufferInfo, gl.TRIANGLES);\n        }\n\n        this._regionId = null;\n    }\n\n    /**\n     * Get the convex hull points for a particular Drawable.\n     * To do this, draw the Drawable unrotated, unscaled, and untranslated.\n     * Read back the pixels and find all boundary points.\n     * Finally, apply a convex hull algorithm to simplify the set.\n     * @param {int} drawableID The Drawable IDs calculate convex hull for.\n     * @return {Array<Array<number>>} points Convex hull points, as [[x, y], ...]\n     */\n    _getConvexHullPointsForDrawable (drawableID) {\n        const drawable = this._allDrawables[drawableID];\n        const [width, height] = drawable.skin.size;\n        // No points in the hull if invisible or size is 0.\n        if (!drawable.getVisible() || width === 0 || height === 0) {\n            return [];\n        }\n\n        /**\n         * Return the determinant of two vectors, the vector from A to B and\n         * the vector from A to C.\n         *\n         * The determinant is useful in this case to know if AC is counter\n         * clockwise from AB. A positive value means the AC is counter\n         * clockwise from AC. A negative value menas AC is clockwise from AB.\n         *\n         * @param {Float32Array} A A 2d vector in space.\n         * @param {Float32Array} B A 2d vector in space.\n         * @param {Float32Array} C A 2d vector in space.\n         * @return {number} Greater than 0 if counter clockwise, less than if\n         * clockwise, 0 if all points are on a line.\n         */\n        const CCW = function (A, B, C) {\n            // AB = B - A\n            // AC = C - A\n            // det (AB BC) = AB0 * AC1 - AB1 * AC0\n            return (((B[0] - A[0]) * (C[1] - A[1])) - ((B[1] - A[1]) * (C[0] - A[0])));\n        };\n\n        // https://github.com/LLK/scratch-flash/blob/dcbeeb59d44c3be911545dfe54d\n        // 46a32404f8e69/src/scratch/ScratchCostume.as#L369-L413 Following\n        // RasterHull creation, compare and store left and right values that\n        // maintain a convex shape until that data can be passed to `hull` for\n        // further work.\n        const L = [];\n        const R = [];\n        const _pixelPos = twgl.v3.create();\n        const _effectPos = twgl.v3.create();\n        let ll = -1;\n        let rr = -1;\n        let Q;\n        for (let y = 0; y < height; y++) {\n            _pixelPos[1] = y / height;\n            // Scan from left to right, looking for a touchable spot in the\n            // skin.\n            let x = 0;\n            for (; x < width; x++) {\n                _pixelPos[0] = x / width;\n                EffectTransform.transformPoint(drawable, _pixelPos, _effectPos);\n                if (drawable.skin.isTouchingLinear(_effectPos)) {\n                    Q = [x, y];\n                    break;\n                }\n            }\n            // If x is equal to the width there are no touchable points in the\n            // skin. Nothing we can add to L. And looping for R would find the\n            // same thing.\n            if (x >= width) {\n                continue;\n            }\n            // Decrement ll until Q is clockwise (CCW returns negative) from the\n            // last two points in L.\n            while (ll > 0) {\n                if (CCW(L[ll - 1], L[ll], Q) < 0) {\n                    break;\n                } else {\n                    --ll;\n                }\n            }\n            // Increment ll and then set L[ll] to Q. If ll was -1 before this\n            // line, this will set L[0] to Q. If ll was 0 before this line, this\n            // will set L[1] to Q.\n            L[++ll] = Q;\n\n            // Scan from right to left, looking for a touchable spot in the\n            // skin.\n            for (x = width - 1; x >= 0; x--) {\n                _pixelPos[0] = x / width;\n                EffectTransform.transformPoint(drawable, _pixelPos, _effectPos);\n                if (drawable.skin.isTouchingLinear(_effectPos)) {\n                    Q = [x, y];\n                    break;\n                }\n            }\n            // Decrement rr until Q is counter clockwise (CCW returns positive)\n            // from the last two points in L. L takes clockwise points and R\n            // takes counter clockwise points. if y was decremented instead of\n            // incremented R would take clockwise points. We are going in the\n            // right direction for L and the wrong direction for R, so we\n            // compare the opposite value for R from L.\n            while (rr > 0) {\n                if (CCW(R[rr - 1], R[rr], Q) > 0) {\n                    break;\n                } else {\n                    --rr;\n                }\n            }\n            // Increment rr and then set R[rr] to Q.\n            R[++rr] = Q;\n        }\n\n        // Known boundary points on left/right edges of pixels.\n        const boundaryPoints = L;\n        // Truncate boundaryPoints to the index of the last added Q to L. L may\n        // have more entries than the index for the last Q.\n        boundaryPoints.length = ll + 1;\n        // Add points in R to boundaryPoints in reverse so all points in\n        // boundaryPoints are clockwise from each other.\n        for (let j = rr; j >= 0; --j) {\n            boundaryPoints.push(R[j]);\n        }\n        // Simplify boundary points using convex hull.\n        return hull(boundaryPoints, Infinity);\n    }\n\n    /**\n     * Sample a \"final\" color from an array of drawables at a given scratch space.\n     * Will blend any alpha values with the drawables \"below\" it.\n     * @param {twgl.v3} vec Scratch Vector Space to sample\n     * @param {Array<Drawables>} drawables A list of drawables with the \"top most\"\n     *              drawable at index 0\n     * @param {Uint8ClampedArray} dst The color3b space to store the answer in.\n     * @return {Uint8ClampedArray} The dst vector with everything blended down.\n     */\n    static sampleColor3b (vec, drawables, dst) {\n        dst = dst || new Uint8ClampedArray(3);\n        dst.fill(0);\n        let blendAlpha = 1;\n        for (let index = 0; blendAlpha !== 0 && index < drawables.length; index++) {\n            /*\n            if (left > vec[0] || right < vec[0] ||\n                bottom > vec[1] || top < vec[0]) {\n                continue;\n            }\n            */\n            Drawable.sampleColor4b(vec, drawables[index].drawable, __blendColor);\n            // if we are fully transparent, go to the next one \"down\"\n            const sampleAlpha = __blendColor[3] / 255;\n            // premultiply alpha\n            dst[0] += __blendColor[0] * blendAlpha * sampleAlpha;\n            dst[1] += __blendColor[1] * blendAlpha * sampleAlpha;\n            dst[2] += __blendColor[2] * blendAlpha * sampleAlpha;\n            blendAlpha *= (1 - sampleAlpha);\n        }\n        // Backdrop could be transparent, so we need to go to the \"clear color\" of the\n        // draw scene (white) as a fallback if everything was alpha\n        dst[0] += blendAlpha * 255;\n        dst[1] += blendAlpha * 255;\n        dst[2] += blendAlpha * 255;\n        return dst;\n    }\n\n    /**\n     * @callback RenderWebGL#snapshotCallback\n     * @param {string} dataURI Data URI of the snapshot of the renderer\n     */\n\n    /**\n     * @param {snapshotCallback} callback Function called in the next frame with the snapshot data\n     */\n    requestSnapshot (callback) {\n        this._snapshotCallbacks.push(callback);\n    }\n}\n\n// :3\nRenderWebGL.prototype.canHazPixels = RenderWebGL.prototype.extractDrawable;\n\nmodule.exports = RenderWebGL;\n","module.exports = require(\"hull.js\");","const twgl = require('twgl.js');\n\nconst Skin = require('./Skin');\n\nclass BitmapSkin extends Skin {\n    /**\n     * Create a new Bitmap Skin.\n     * @extends Skin\n     * @param {!int} id - The ID for this Skin.\n     * @param {!RenderWebGL} renderer - The renderer which will use this skin.\n     */\n    constructor (id, renderer) {\n        super(id);\n\n        /** @type {!int} */\n        this._costumeResolution = 1;\n\n        /** @type {!RenderWebGL} */\n        this._renderer = renderer;\n\n        /** @type {WebGLTexture} */\n        this._texture = null;\n\n        /** @type {Array<int>} */\n        this._textureSize = [0, 0];\n    }\n\n    /**\n     * Dispose of this object. Do not use it after calling this method.\n     */\n    dispose () {\n        if (this._texture) {\n            this._renderer.gl.deleteTexture(this._texture);\n            this._texture = null;\n        }\n        super.dispose();\n    }\n\n    /**\n     * @returns {boolean} true for a raster-style skin (like a BitmapSkin), false for vector-style (like SVGSkin).\n     */\n    get isRaster () {\n        return true;\n    }\n\n    /**\n     * @return {Array<number>} the \"native\" size, in texels, of this skin.\n     */\n    get size () {\n        return [this._textureSize[0] / this._costumeResolution, this._textureSize[1] / this._costumeResolution];\n    }\n\n    /**\n     * @param {Array<number>} scale - The scaling factors to be used.\n     * @return {WebGLTexture} The GL texture representation of this skin when drawing at the given scale.\n     */\n    // eslint-disable-next-line no-unused-vars\n    getTexture (scale) {\n        return this._texture;\n    }\n\n    /**\n     * Set the contents of this skin to a snapshot of the provided bitmap data.\n     * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} bitmapData - new contents for this skin.\n     * @param {int} [costumeResolution=1] - The resolution to use for this bitmap.\n     * @param {Array<number>} [rotationCenter] - Optional rotation center for the bitmap. If not supplied, it will be\n     * calculated from the bounding box\n     * @fires Skin.event:WasAltered\n     */\n    setBitmap (bitmapData, costumeResolution, rotationCenter) {\n        const gl = this._renderer.gl;\n\n        if (this._texture) {\n            gl.bindTexture(gl.TEXTURE_2D, this._texture);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bitmapData);\n            this._silhouette.update(bitmapData);\n        } else {\n            // TODO: mipmaps?\n            const textureOptions = {\n                auto: true,\n                wrap: gl.CLAMP_TO_EDGE,\n                src: bitmapData\n            };\n\n            this._texture = twgl.createTexture(gl, textureOptions);\n            this._silhouette.update(bitmapData);\n        }\n\n        // Do these last in case any of the above throws an exception\n        this._costumeResolution = costumeResolution || 2;\n        this._textureSize = BitmapSkin._getBitmapSize(bitmapData);\n\n        if (typeof rotationCenter === 'undefined') rotationCenter = this.calculateRotationCenter();\n        this.setRotationCenter.apply(this, rotationCenter);\n\n        this.emit(Skin.Events.WasAltered);\n    }\n\n    /**\n     * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} bitmapData - bitmap data to inspect.\n     * @returns {Array<int>} the width and height of the bitmap data, in pixels.\n     * @private\n     */\n    static _getBitmapSize (bitmapData) {\n        if (bitmapData instanceof HTMLImageElement) {\n            return [bitmapData.naturalWidth || bitmapData.width, bitmapData.naturalHeight || bitmapData.height];\n        }\n\n        if (bitmapData instanceof HTMLVideoElement) {\n            return [bitmapData.videoWidth || bitmapData.width, bitmapData.videoHeight || bitmapData.height];\n        }\n\n        // ImageData or HTMLCanvasElement\n        return [bitmapData.width, bitmapData.height];\n    }\n\n}\n\nmodule.exports = BitmapSkin;\n","/**\n * @fileoverview\n * A representation of a Skin's silhouette that can test if a point on the skin\n * renders a pixel where it is drawn.\n */\n\n/**\n * <canvas> element used to update Silhouette data from skin bitmap data.\n * @type {CanvasElement}\n */\nlet __SilhouetteUpdateCanvas;\n\n/**\n * Internal helper function (in hopes that compiler can inline).  Get a pixel\n * from silhouette data, or 0 if outside it's bounds.\n * @private\n * @param {Silhouette} silhouette - has data width and height\n * @param {number} x - x\n * @param {number} y - y\n * @return {number} Alpha value for x/y position\n */\nconst getPoint = ({_width: width, _height: height, _data: data}, x, y) => {\n    // 0 if outside bouds, otherwise read from data.\n    if (x >= width || y >= height || x < 0 || y < 0) {\n        return 0;\n    }\n    return data[(y * width) + x];\n};\n\n/**\n * Memory buffers for doing 4 corner sampling for linear interpolation\n */\nconst __cornerWork = [\n    new Uint8ClampedArray(4),\n    new Uint8ClampedArray(4),\n    new Uint8ClampedArray(4),\n    new Uint8ClampedArray(4)\n];\n\n/**\n * Get the color from a given silhouette at an x/y local texture position.\n * @param {Silhouette} The silhouette to sample.\n * @param {number} x X position of texture (0-1).\n * @param {number} y Y position of texture (0-1).\n * @param {Uint8ClampedArray} dst A color 4b space.\n * @return {Uint8ClampedArray} The dst vector.\n */\nconst getColor4b = ({_width: width, _height: height, _colorData: data}, x, y, dst) => {\n    // 0 if outside bouds, otherwise read from data.\n    if (x >= width || y >= height || x < 0 || y < 0) {\n        return dst.fill(0);\n    }\n    const offset = ((y * width) + x) * 4;\n    dst[0] = data[offset];\n    dst[1] = data[offset + 1];\n    dst[2] = data[offset + 2];\n    dst[3] = data[offset + 3];\n    return dst;\n};\n\nclass Silhouette {\n    constructor () {\n        /**\n         * The width of the data representing the current skin data.\n         * @type {number}\n         */\n        this._width = 0;\n\n        /**\n         * The height of the data representing the current skin date.\n         * @type {number}\n         */\n        this._height = 0;\n\n        /**\n         * The data representing a skin's silhouette shape.\n         * @type {Uint8ClampedArray}\n         */\n        this._data = null;\n        this._colorData = null;\n\n        this.colorAtNearest = this.colorAtLinear = (_, dst) => dst.fill(0);\n    }\n\n    /**\n     * Update this silhouette with the bitmapData for a skin.\n     * @param {*} bitmapData An image, canvas or other element that the skin\n     * rendering can be queried from.\n     */\n    update (bitmapData) {\n        const canvas = Silhouette._updateCanvas();\n        const width = this._width = canvas.width = bitmapData.width;\n        const height = this._height = canvas.height = bitmapData.height;\n        const ctx = canvas.getContext('2d');\n\n        if (!(width && height)) {\n            return;\n        }\n        ctx.clearRect(0, 0, width, height);\n        ctx.drawImage(bitmapData, 0, 0, width, height);\n        const imageData = ctx.getImageData(0, 0, width, height);\n\n        this._data = new Uint8ClampedArray(imageData.data.length / 4);\n        this._colorData = imageData.data;\n        // delete our custom overriden \"uninitalized\" color functions\n        // let the prototype work for itself\n        delete this.colorAtNearest;\n        delete this.colorAtLinear;\n\n        for (let i = 0; i < imageData.data.length; i += 4) {\n            this._data[i / 4] = imageData.data[i + 3];\n        }\n    }\n\n    /**\n     * Sample a color from the silhouette at a given local position using\n     * \"nearest neighbor\"\n     * @param {twgl.v3} vec [x,y] texture space (0-1)\n     * @param {Uint8ClampedArray} dst The memory buffer to store the value in. (4 bytes)\n     * @returns {Uint8ClampedArray} dst\n     */\n    colorAtNearest (vec, dst) {\n        return getColor4b(\n            this,\n            Math.floor(vec[0] * (this._width - 1)),\n            Math.floor(vec[1] * (this._height - 1)),\n            dst\n        );\n    }\n\n    /**\n     * Sample a color from the silhouette at a given local position using\n     * \"linear interpolation\"\n     * @param {twgl.v3} vec [x,y] texture space (0-1)\n     * @param {Uint8ClampedArray} dst The memory buffer to store the value in. (4 bytes)\n     * @returns {Uint8ClampedArray} dst\n     */\n    colorAtLinear (vec, dst) {\n        const x = vec[0] * (this._width - 1);\n        const y = vec[1] * (this._height - 1);\n\n        const x1D = x % 1;\n        const y1D = y % 1;\n        const x0D = 1 - x1D;\n        const y0D = 1 - y1D;\n\n        const xFloor = Math.floor(x);\n        const yFloor = Math.floor(y);\n\n        const x0y0 = getColor4b(this, xFloor, yFloor, __cornerWork[0]);\n        const x1y0 = getColor4b(this, xFloor + 1, yFloor, __cornerWork[1]);\n        const x0y1 = getColor4b(this, xFloor, yFloor + 1, __cornerWork[2]);\n        const x1y1 = getColor4b(this, xFloor + 1, yFloor + 1, __cornerWork[3]);\n\n        dst[0] = (x0y0[0] * x0D * y0D) + (x0y1[0] * x0D * y1D) + (x1y0[0] * x1D * y0D) + (x1y1[0] * x1D * y1D);\n        dst[1] = (x0y0[1] * x0D * y0D) + (x0y1[1] * x0D * y1D) + (x1y0[1] * x1D * y0D) + (x1y1[1] * x1D * y1D);\n        dst[2] = (x0y0[2] * x0D * y0D) + (x0y1[2] * x0D * y1D) + (x1y0[2] * x1D * y0D) + (x1y1[2] * x1D * y1D);\n        dst[3] = (x0y0[3] * x0D * y0D) + (x0y1[3] * x0D * y1D) + (x1y0[3] * x1D * y0D) + (x1y1[3] * x1D * y1D);\n\n        return dst;\n    }\n\n    /**\n     * Test if texture coordinate touches the silhouette using nearest neighbor.\n     * @param {twgl.v3} vec A texture coordinate.\n     * @return {boolean} If the nearest pixel has an alpha value.\n     */\n    isTouchingNearest (vec) {\n        if (!this._data) return;\n        return getPoint(\n            this,\n            Math.floor(vec[0] * (this._width - 1)),\n            Math.floor(vec[1] * (this._height - 1))\n        ) > 0;\n    }\n\n    /**\n     * Test to see if any of the 4 pixels used in the linear interpolate touch\n     * the silhouette.\n     * @param {twgl.v3} vec A texture coordinate.\n     * @return {boolean} Any of the pixels have some alpha.\n     */\n    isTouchingLinear (vec) {\n        if (!this._data) return;\n        const x = Math.floor(vec[0] * (this._width - 1));\n        const y = Math.floor(vec[1] * (this._height - 1));\n        return getPoint(this, x, y) > 0 ||\n            getPoint(this, x + 1, y) > 0 ||\n            getPoint(this, x, y + 1) > 0 ||\n            getPoint(this, x + 1, y + 1) > 0;\n    }\n\n    /**\n     * Get the canvas element reused by Silhouettes to update their data with.\n     * @private\n     * @return {CanvasElement} A canvas to draw bitmap data to.\n     */\n    static _updateCanvas () {\n        if (typeof __SilhouetteUpdateCanvas === 'undefined') {\n            __SilhouetteUpdateCanvas = document.createElement('canvas');\n        }\n        return __SilhouetteUpdateCanvas;\n    }\n}\n\nmodule.exports = Silhouette;\n","const twgl = require('twgl.js');\n\nconst Rectangle = require('./Rectangle');\nconst RenderConstants = require('./RenderConstants');\nconst ShaderManager = require('./ShaderManager');\nconst Skin = require('./Skin');\nconst EffectTransform = require('./EffectTransform');\n\n/**\n * An internal workspace for calculating texture locations from world vectors\n * this is REUSED for memory conservation reasons\n * @type {twgl.v3}\n */\nconst __isTouchingPosition = twgl.v3.create();\n\n/**\n * Convert a scratch space location into a texture space float.  Uses the\n * internal __isTouchingPosition as a return value, so this should be copied\n * if you ever need to get two local positions and store both.  Requires that\n * the drawable inverseMatrix is up to date.\n *\n * @param {Drawable} drawable The drawable to get the inverse matrix and uniforms from\n * @param {twgl.v3} vec [x,y] scratch space vector\n * @return {twgl.v3} [x,y] texture space float vector - transformed by effects and matrix\n */\nconst getLocalPosition = (drawable, vec) => {\n    // Transfrom from world coordinates to Drawable coordinates.\n    const localPosition = __isTouchingPosition;\n    const v0 = vec[0];\n    const v1 = vec[1];\n    const m = drawable._inverseMatrix;\n    // var v2 = v[2];\n    const d = (v0 * m[3]) + (v1 * m[7]) + m[15];\n    // The RenderWebGL quad flips the texture's X axis. So rendered bottom\n    // left is 1, 0 and the top right is 0, 1. Flip the X axis so\n    // localPosition matches that transformation.\n    localPosition[0] = 0.5 - (((v0 * m[0]) + (v1 * m[4]) + m[12]) / d);\n    localPosition[1] = (((v0 * m[1]) + (v1 * m[5]) + m[13]) / d) + 0.5;\n    // Apply texture effect transform.\n    EffectTransform.transformPoint(drawable, localPosition, localPosition);\n    return localPosition;\n};\n\nclass Drawable {\n    /**\n     * An object which can be drawn by the renderer.\n     * @todo double-buffer all rendering state (position, skin, effects, etc.)\n     * @param {!int} id - This Drawable's unique ID.\n     * @constructor\n     */\n    constructor (id) {\n        /** @type {!int} */\n        this._id = id;\n\n        /**\n         * The uniforms to be used by the vertex and pixel shaders.\n         * Some of these are used by other parts of the renderer as well.\n         * @type {Object.<string,*>}\n         * @private\n         */\n        this._uniforms = {\n            /**\n             * The model matrix, to concat with projection at draw time.\n             * @type {module:twgl/m4.Mat4}\n             */\n            u_modelMatrix: twgl.m4.identity(),\n\n            /**\n             * The color to use in the silhouette draw mode.\n             * @type {Array<number>}\n             */\n            u_silhouetteColor: Drawable.color4fFromID(this._id)\n        };\n\n        // Effect values are uniforms too\n        const numEffects = ShaderManager.EFFECTS.length;\n        for (let index = 0; index < numEffects; ++index) {\n            const effectName = ShaderManager.EFFECTS[index];\n            const effectInfo = ShaderManager.EFFECT_INFO[effectName];\n            const converter = effectInfo.converter;\n            this._uniforms[effectInfo.uniformName] = converter(0);\n        }\n\n        this._position = twgl.v3.create(0, 0);\n        this._scale = twgl.v3.create(100, 100);\n        this._direction = 90;\n        this._transformDirty = true;\n        this._rotationMatrix = twgl.m4.identity();\n        this._rotationTransformDirty = true;\n        this._rotationAdjusted = twgl.v3.create();\n        this._rotationCenterDirty = true;\n        this._skinScale = twgl.v3.create(0, 0, 0);\n        this._skinScaleDirty = true;\n        this._inverseMatrix = twgl.m4.identity();\n        this._inverseTransformDirty = true;\n        this._visible = true;\n        this._effectBits = 0;\n\n        /** @todo move convex hull functionality, maybe bounds functionality overall, to Skin classes */\n        this._convexHullPoints = null;\n        this._convexHullDirty = true;\n\n        this._skinWasAltered = this._skinWasAltered.bind(this);\n    }\n\n    /**\n     * Dispose of this Drawable. Do not use it after calling this method.\n     */\n    dispose () {\n        // Use the setter: disconnect events\n        this.skin = null;\n    }\n\n    /**\n     * Mark this Drawable's transform as dirty.\n     * It will be recalculated next time it's needed.\n     */\n    setTransformDirty () {\n        this._transformDirty = true;\n        this._inverseTransformDirty = true;\n    }\n\n    /**\n     * @returns {number} The ID for this Drawable.\n     */\n    get id () {\n        return this._id;\n    }\n\n    /**\n     * @returns {Skin} the current skin for this Drawable.\n     */\n    get skin () {\n        return this._skin;\n    }\n\n    /**\n     * @param {Skin} newSkin - A new Skin for this Drawable.\n     */\n    set skin (newSkin) {\n        if (this._skin !== newSkin) {\n            if (this._skin) {\n                this._skin.removeListener(Skin.Events.WasAltered, this._skinWasAltered);\n            }\n            this._skin = newSkin;\n            if (this._skin) {\n                this._skin.addListener(Skin.Events.WasAltered, this._skinWasAltered);\n            }\n            this._skinWasAltered();\n        }\n    }\n\n    /**\n     * @returns {Array<number>} the current scaling percentages applied to this Drawable. [100,100] is normal size.\n     */\n    get scale () {\n        return [this._scale[0], this._scale[1]];\n    }\n\n    /**\n     * @returns {int} A bitmask identifying which effects are currently in use.\n     */\n    getEnabledEffects () {\n        return this._effectBits;\n    }\n\n    /**\n     * @returns {object.<string, *>} the shader uniforms to be used when rendering this Drawable.\n     */\n    getUniforms () {\n        if (this._transformDirty) {\n            this._calculateTransform();\n        }\n        return this._uniforms;\n    }\n\n    /**\n     * @returns {boolean} whether this Drawable is visible.\n     */\n    getVisible () {\n        return this._visible;\n    }\n\n    /**\n     * Update the position, direction, scale, or effect properties of this Drawable.\n     * @param {object.<string,*>} properties The new property values to set.\n     */\n    updateProperties (properties) {\n        let dirty = false;\n        if ('position' in properties && (\n            this._position[0] !== properties.position[0] ||\n            this._position[1] !== properties.position[1])) {\n            this._position[0] = Math.round(properties.position[0]);\n            this._position[1] = Math.round(properties.position[1]);\n            dirty = true;\n        }\n        if ('direction' in properties && this._direction !== properties.direction) {\n            this._direction = properties.direction;\n            this._rotationTransformDirty = true;\n            dirty = true;\n        }\n        if ('scale' in properties && (\n            this._scale[0] !== properties.scale[0] ||\n            this._scale[1] !== properties.scale[1])) {\n            this._scale[0] = properties.scale[0];\n            this._scale[1] = properties.scale[1];\n            this._rotationCenterDirty = true;\n            this._skinScaleDirty = true;\n            dirty = true;\n        }\n        if ('visible' in properties) {\n            this._visible = properties.visible;\n            this.setConvexHullDirty();\n        }\n        if (dirty) {\n            this.setTransformDirty();\n        }\n        const numEffects = ShaderManager.EFFECTS.length;\n        for (let index = 0; index < numEffects; ++index) {\n            const effectName = ShaderManager.EFFECTS[index];\n            if (effectName in properties) {\n                const rawValue = properties[effectName];\n                const effectInfo = ShaderManager.EFFECT_INFO[effectName];\n                if (rawValue) {\n                    this._effectBits |= effectInfo.mask;\n                } else {\n                    this._effectBits &= ~effectInfo.mask;\n                }\n                const converter = effectInfo.converter;\n                this._uniforms[effectInfo.uniformName] = converter(rawValue);\n                if (effectInfo.shapeChanges) {\n                    this.setConvexHullDirty();\n                }\n            }\n        }\n    }\n\n    /**\n     * Calculate the transform to use when rendering this Drawable.\n     * @private\n     */\n    _calculateTransform () {\n        if (this._rotationTransformDirty) {\n            const rotation = (270 - this._direction) * Math.PI / 180;\n\n            // Calling rotationZ sets the destination matrix to a rotation\n            // around the Z axis setting matrix components 0, 1, 4 and 5 with\n            // cosine and sine values of the rotation.\n            // twgl.m4.rotationZ(rotation, this._rotationMatrix);\n\n            // twgl assumes the last value set to the matrix was anything.\n            // Drawable knows, it was another rotationZ matrix, so we can skip\n            // assigning the values that will never change.\n            const c = Math.cos(rotation);\n            const s = Math.sin(rotation);\n            this._rotationMatrix[0] = c;\n            this._rotationMatrix[1] = s;\n            // this._rotationMatrix[2] = 0;\n            // this._rotationMatrix[3] = 0;\n            this._rotationMatrix[4] = -s;\n            this._rotationMatrix[5] = c;\n            // this._rotationMatrix[6] = 0;\n            // this._rotationMatrix[7] = 0;\n            // this._rotationMatrix[8] = 0;\n            // this._rotationMatrix[9] = 0;\n            // this._rotationMatrix[10] = 1;\n            // this._rotationMatrix[11] = 0;\n            // this._rotationMatrix[12] = 0;\n            // this._rotationMatrix[13] = 0;\n            // this._rotationMatrix[14] = 0;\n            // this._rotationMatrix[15] = 1;\n\n            this._rotationTransformDirty = false;\n        }\n\n        // Adjust rotation center relative to the skin.\n        if (this._rotationCenterDirty && this.skin !== null) {\n            // twgl version of the following in function work.\n            // let rotationAdjusted = twgl.v3.subtract(\n            //     this.skin.rotationCenter,\n            //     twgl.v3.divScalar(this.skin.size, 2, this._rotationAdjusted),\n            //     this._rotationAdjusted\n            // );\n            // rotationAdjusted = twgl.v3.multiply(\n            //     rotationAdjusted, this._scale, rotationAdjusted\n            // );\n            // rotationAdjusted = twgl.v3.divScalar(\n            //     rotationAdjusted, 100, rotationAdjusted\n            // );\n            // rotationAdjusted[1] *= -1; // Y flipped to Scratch coordinate.\n            // rotationAdjusted[2] = 0; // Z coordinate is 0.\n\n            // Locally assign rotationCenter and skinSize to keep from having\n            // the Skin getter properties called twice while locally assigning\n            // their components for readability.\n            const rotationCenter = this.skin.rotationCenter;\n            const skinSize = this.skin.size;\n            const center0 = rotationCenter[0];\n            const center1 = rotationCenter[1];\n            const skinSize0 = skinSize[0];\n            const skinSize1 = skinSize[1];\n            const scale0 = this._scale[0];\n            const scale1 = this._scale[1];\n\n            const rotationAdjusted = this._rotationAdjusted;\n            rotationAdjusted[0] = (center0 - (skinSize0 / 2)) * scale0 / 100;\n            rotationAdjusted[1] = ((center1 - (skinSize1 / 2)) * scale1 / 100) * -1;\n            // rotationAdjusted[2] = 0;\n\n            this._rotationCenterDirty = false;\n        }\n\n        if (this._skinScaleDirty && this.skin !== null) {\n            // twgl version of the following in function work.\n            // const scaledSize = twgl.v3.divScalar(\n            //     twgl.v3.multiply(this.skin.size, this._scale),\n            //     100\n            // );\n            // // was NaN because the vectors have only 2 components.\n            // scaledSize[2] = 0;\n\n            // Locally assign skinSize to keep from having the Skin getter\n            // properties called twice.\n            const skinSize = this.skin.size;\n            const scaledSize = this._skinScale;\n            scaledSize[0] = skinSize[0] * this._scale[0] / 100;\n            scaledSize[1] = skinSize[1] * this._scale[1] / 100;\n            // scaledSize[2] = 0;\n\n            this._skinScaleDirty = false;\n        }\n\n        const modelMatrix = this._uniforms.u_modelMatrix;\n\n        // twgl version of the following in function work.\n        // twgl.m4.identity(modelMatrix);\n        // twgl.m4.translate(modelMatrix, this._position, modelMatrix);\n        // twgl.m4.multiply(modelMatrix, this._rotationMatrix, modelMatrix);\n        // twgl.m4.translate(modelMatrix, this._rotationAdjusted, modelMatrix);\n        // twgl.m4.scale(modelMatrix, scaledSize, modelMatrix);\n\n        // Drawable configures a 3D matrix for drawing in WebGL, but most values\n        // will never be set because the inputs are on the X and Y position axis\n        // and the Z rotation axis. Drawable can bring the work inside\n        // _calculateTransform and greatly reduce the ammount of math and array\n        // assignments needed.\n\n        const scale0 = this._skinScale[0];\n        const scale1 = this._skinScale[1];\n        const rotation00 = this._rotationMatrix[0];\n        const rotation01 = this._rotationMatrix[1];\n        const rotation10 = this._rotationMatrix[4];\n        const rotation11 = this._rotationMatrix[5];\n        const adjusted0 = this._rotationAdjusted[0];\n        const adjusted1 = this._rotationAdjusted[1];\n        const position0 = this._position[0];\n        const position1 = this._position[1];\n\n        // Commented assignments show what the values are when the matrix was\n        // instantiated. Those values will never change so they do not need to\n        // be reassigned.\n        modelMatrix[0] = scale0 * rotation00;\n        modelMatrix[1] = scale0 * rotation01;\n        // modelMatrix[2] = 0;\n        // modelMatrix[3] = 0;\n        modelMatrix[4] = scale1 * rotation10;\n        modelMatrix[5] = scale1 * rotation11;\n        // modelMatrix[6] = 0;\n        // modelMatrix[7] = 0;\n        // modelMatrix[8] = 0;\n        // modelMatrix[9] = 0;\n        // modelMatrix[10] = 1;\n        // modelMatrix[11] = 0;\n        modelMatrix[12] = (rotation00 * adjusted0) + (rotation10 * adjusted1) + position0;\n        modelMatrix[13] = (rotation01 * adjusted0) + (rotation11 * adjusted1) + position1;\n        // modelMatrix[14] = 0;\n        // modelMatrix[15] = 1;\n\n        this._transformDirty = false;\n    }\n\n    /**\n     * Whether the Drawable needs convex hull points provided by the renderer.\n     * @return {boolean} True when no convex hull known, or it's dirty.\n     */\n    needsConvexHullPoints () {\n        return !this._convexHullPoints || this._convexHullDirty || this._convexHullPoints.length === 0;\n    }\n\n    /**\n     * Set the convex hull to be dirty.\n     * Do this whenever the Drawable's shape has possibly changed.\n     */\n    setConvexHullDirty () {\n        this._convexHullDirty = true;\n    }\n\n    /**\n     * Set the convex hull points for the Drawable.\n     * @param {Array<Array<number>>} points Convex hull points, as [[x, y], ...]\n     */\n    setConvexHullPoints (points) {\n        this._convexHullPoints = points;\n        this._convexHullDirty = false;\n    }\n\n    /**\n     * Check if the world position touches the skin.\n     * @param {twgl.v3} vec World coordinate vector.\n     * @return {boolean} True if the world position touches the skin.\n     */\n    isTouching (vec) {\n        if (!this.skin) {\n            return false;\n        }\n\n        const localPosition = getLocalPosition(this, vec);\n\n        if (this.useNearest) {\n            return this.skin.isTouchingNearest(localPosition);\n        }\n        return this.skin.isTouchingLinear(localPosition);\n    }\n\n    /**\n     * Should the drawable use NEAREST NEIGHBOR or LINEAR INTERPOLATION mode\n     */\n    get useNearest () {\n        // Raster skins (bitmaps) should always prefer nearest neighbor\n        if (this.skin.isRaster) {\n            return true;\n        }\n\n        // We can't use nearest neighbor unless we are a multiple of 90 rotation\n        if (this._direction % 90 !== 0) {\n            return false;\n        }\n\n        // If the scale of the skin is very close to 100 (0.99999 variance is okay I guess)\n        if (Math.abs(this.scale[0]) > 99 && Math.abs(this.scale[0]) < 101 &&\n            Math.abs(this.scale[1]) > 99 && Math.abs(this.scale[1]) < 101) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Get the precise bounds for a Drawable.\n     * This function applies the transform matrix to the known convex hull,\n     * and then finds the minimum box along the axes.\n     * Before calling this, ensure the renderer has updated convex hull points.\n     * @return {!Rectangle} Bounds for a tight box around the Drawable.\n     */\n    getBounds () {\n        if (this.needsConvexHullPoints()) {\n            throw new Error('Needs updated convex hull points before bounds calculation.');\n        }\n        if (this._transformDirty) {\n            this._calculateTransform();\n        }\n        const transformedHullPoints = this._getTransformedHullPoints();\n        // Search through transformed points to generate box on axes.\n        const bounds = new Rectangle();\n        bounds.initFromPointsAABB(transformedHullPoints);\n        return bounds;\n    }\n\n    /**\n     * Get the precise bounds for the upper 8px slice of the Drawable.\n     * Used for calculating where to position a text bubble.\n     * Before calling this, ensure the renderer has updated convex hull points.\n     * @return {!Rectangle} Bounds for a tight box around a slice of the Drawable.\n     */\n    getBoundsForBubble () {\n        if (this.needsConvexHullPoints()) {\n            throw new Error('Needs updated convex hull points before bubble bounds calculation.');\n        }\n        if (this._transformDirty) {\n            this._calculateTransform();\n        }\n        const slice = 8; // px, how tall the top slice to measure should be.\n        const transformedHullPoints = this._getTransformedHullPoints();\n        const maxY = Math.max.apply(null, transformedHullPoints.map(p => p[1]));\n        const filteredHullPoints = transformedHullPoints.filter(p => p[1] > maxY - slice);\n        // Search through filtered points to generate box on axes.\n        const bounds = new Rectangle();\n        bounds.initFromPointsAABB(filteredHullPoints);\n        return bounds;\n    }\n\n    /**\n     * Get the rough axis-aligned bounding box for the Drawable.\n     * Calculated by transforming the skin's bounds.\n     * Note that this is less precise than the box returned by `getBounds`,\n     * which is tightly snapped to account for a Drawable's transparent regions.\n     * `getAABB` returns a much less accurate bounding box, but will be much\n     * faster to calculate so may be desired for quick checks/optimizations.\n     * @return {!Rectangle} Rough axis-aligned bounding box for Drawable.\n     */\n    getAABB () {\n        if (this._transformDirty) {\n            this._calculateTransform();\n        }\n        const tm = this._uniforms.u_modelMatrix;\n        const bounds = new Rectangle();\n        bounds.initFromPointsAABB([\n            twgl.m4.transformPoint(tm, [-0.5, -0.5, 0]),\n            twgl.m4.transformPoint(tm, [0.5, -0.5, 0]),\n            twgl.m4.transformPoint(tm, [-0.5, 0.5, 0]),\n            twgl.m4.transformPoint(tm, [0.5, 0.5, 0])\n        ]);\n        return bounds;\n    }\n\n    /**\n     * Return the best Drawable bounds possible without performing graphics queries.\n     * I.e., returns the tight bounding box when the convex hull points are already\n     * known, but otherwise return the rough AABB of the Drawable.\n     * @return {!Rectangle} Bounds for the Drawable.\n     */\n    getFastBounds () {\n        this.updateMatrix();\n        if (!this.needsConvexHullPoints()) {\n            return this.getBounds();\n        }\n        return this.getAABB();\n    }\n\n    /**\n     * Transform all the convex hull points by the current Drawable's\n     * transform. This allows us to skip recalculating the convex hull\n     * for many Drawable updates, including translation, rotation, scaling.\n     * @return {!Array.<!Array.number>} Array of glPoints which are Array<x, y>\n     * @private\n     */\n    _getTransformedHullPoints () {\n        const projection = twgl.m4.ortho(-1, 1, -1, 1, -1, 1);\n        const skinSize = this.skin.size;\n        const halfXPixel = 1 / skinSize[0] / 2;\n        const halfYPixel = 1 / skinSize[1] / 2;\n        const tm = twgl.m4.multiply(this._uniforms.u_modelMatrix, projection);\n        const transformedHullPoints = [];\n        for (let i = 0; i < this._convexHullPoints.length; i++) {\n            const point = this._convexHullPoints[i];\n            const glPoint = twgl.v3.create(\n                0.5 + (-point[0] / skinSize[0]) - halfXPixel,\n                (point[1] / skinSize[1]) - 0.5 + halfYPixel,\n                0\n            );\n            twgl.m4.transformPoint(tm, glPoint, glPoint);\n            transformedHullPoints.push(glPoint);\n        }\n        return transformedHullPoints;\n    }\n\n    /**\n     * Update the transform matrix and calculate it's inverse for collision\n     * and local texture position purposes.\n     */\n    updateMatrix () {\n        if (this._transformDirty) {\n            this._calculateTransform();\n        }\n        // Get the inverse of the model matrix or update it.\n        if (this._inverseTransformDirty) {\n            const inverse = this._inverseMatrix;\n            twgl.m4.copy(this._uniforms.u_modelMatrix, inverse);\n            // The normal matrix uses a z scaling of 0 causing model[10] to be\n            // 0. Getting a 4x4 inverse is impossible without a scaling in x, y,\n            // and z.\n            inverse[10] = 1;\n            twgl.m4.inverse(inverse, inverse);\n            this._inverseTransformDirty = false;\n        }\n    }\n\n    /**\n     * Respond to an internal change in the current Skin.\n     * @private\n     */\n    _skinWasAltered () {\n        this._rotationCenterDirty = true;\n        this._skinScaleDirty = true;\n        this.setConvexHullDirty();\n        this.setTransformDirty();\n    }\n\n    /**\n     * Calculate a color to represent the given ID number. At least one component of\n     * the resulting color will be non-zero if the ID is not RenderConstants.ID_NONE.\n     * @param {int} id The ID to convert.\n     * @returns {Array<number>} An array of [r,g,b,a], each component in the range [0,1].\n     */\n    static color4fFromID (id) {\n        id -= RenderConstants.ID_NONE;\n        const r = ((id >> 0) & 255) / 255.0;\n        const g = ((id >> 8) & 255) / 255.0;\n        const b = ((id >> 16) & 255) / 255.0;\n        return [r, g, b, 1.0];\n    }\n\n    /**\n     * Calculate the ID number represented by the given color. If all components of\n     * the color are zero, the result will be RenderConstants.ID_NONE; otherwise the result\n     * will be a valid ID.\n     * @param {int} r The red value of the color, in the range [0,255].\n     * @param {int} g The green value of the color, in the range [0,255].\n     * @param {int} b The blue value of the color, in the range [0,255].\n     * @returns {int} The ID represented by that color.\n     */\n    static color3bToID (r, g, b) {\n        let id;\n        id = (r & 255) << 0;\n        id |= (g & 255) << 8;\n        id |= (b & 255) << 16;\n        return id + RenderConstants.ID_NONE;\n    }\n\n    /**\n     * Sample a color from a drawable's texture.\n     * @param {twgl.v3} vec The scratch space [x,y] vector\n     * @param {Drawable} drawable The drawable to sample the texture from\n     * @param {Uint8ClampedArray} dst The \"color4b\" representation of the texture at point.\n     * @returns {Uint8ClampedArray} The dst object filled with the color4b\n     */\n    static sampleColor4b (vec, drawable, dst) {\n        const localPosition = getLocalPosition(drawable, vec);\n        if (localPosition[0] < 0 || localPosition[1] < 0 ||\n            localPosition[0] > 1 || localPosition[1] > 1) {\n            dst[3] = 0;\n            return dst;\n        }\n        const textColor =\n        // commenting out to only use nearest for now\n        // drawable.useNearest ?\n             drawable.skin._silhouette.colorAtNearest(localPosition, dst);\n        // : drawable.skin._silhouette.colorAtLinear(localPosition, dst);\n        return EffectTransform.transformColor(drawable, textColor, textColor);\n    }\n}\n\nmodule.exports = Drawable;\n","module.exports = \"uniform mat4 u_projectionMatrix;\\nuniform mat4 u_modelMatrix;\\n\\nattribute vec2 a_position;\\nattribute vec2 a_texCoord;\\n\\nvarying vec2 v_texCoord;\\n\\n#ifdef DRAW_MODE_lineSample\\nuniform float u_positionScalar;\\n#endif\\n\\nvoid main() {\\n    #ifdef DRAW_MODE_lineSample\\n    vec2 position = a_position;\\n    position.y = clamp(position.y * u_positionScalar, -0.5, 0.5);\\n    gl_Position = u_projectionMatrix * u_modelMatrix * vec4(position, 0, 1);\\n    #else\\n    gl_Position = u_projectionMatrix * u_modelMatrix * vec4(a_position, 0, 1);\\n    #endif\\n    v_texCoord = a_texCoord;\\n}\\n\"","module.exports = \"precision mediump float;\\n\\nuniform float u_fudge;\\n\\n#ifdef DRAW_MODE_silhouette\\nuniform vec4 u_silhouetteColor;\\n#else // DRAW_MODE_silhouette\\n# ifdef ENABLE_color\\nuniform float u_color;\\n# endif // ENABLE_color\\n# ifdef ENABLE_brightness\\nuniform float u_brightness;\\n# endif // ENABLE_brightness\\n#endif // DRAW_MODE_silhouette\\n\\n#ifdef DRAW_MODE_colorMask\\nuniform vec3 u_colorMask;\\nuniform float u_colorMaskTolerance;\\n#endif // DRAW_MODE_colorMask\\n\\n#ifdef ENABLE_fisheye\\nuniform float u_fisheye;\\n#endif // ENABLE_fisheye\\n#ifdef ENABLE_whirl\\nuniform float u_whirl;\\n#endif // ENABLE_whirl\\n#ifdef ENABLE_pixelate\\nuniform float u_pixelate;\\nuniform vec2 u_skinSize;\\n#endif // ENABLE_pixelate\\n#ifdef ENABLE_mosaic\\nuniform float u_mosaic;\\n#endif // ENABLE_mosaic\\n#ifdef ENABLE_ghost\\nuniform float u_ghost;\\n#endif // ENABLE_ghost\\n\\n#ifdef DRAW_MODE_lineSample\\nuniform vec4 u_lineColor;\\nuniform float u_capScale;\\nuniform float u_aliasAmount;\\n#endif // DRAW_MODE_lineSample\\n\\nuniform sampler2D u_skin;\\n\\nvarying vec2 v_texCoord;\\n\\n#if !defined(DRAW_MODE_silhouette) && (defined(ENABLE_color) || defined(ENABLE_brightness))\\n// Branchless color conversions based on code from:\\n// http://www.chilliant.com/rgb2hsv.html by Ian Taylor\\n// Based in part on work by Sam Hocevar and Emil Persson\\n// See also: https://en.wikipedia.org/wiki/HSL_and_HSV#Formal_derivation\\n\\n// Smaller values can cause problems with \\\"color\\\" and \\\"brightness\\\" effects on some mobile devices\\nconst float epsilon = 1e-3;\\n\\n// Convert an RGB color to Hue, Saturation, and Value.\\n// All components of input and output are expected to be in the [0,1] range.\\nvec3 convertRGB2HSV(vec3 rgb)\\n{\\n\\t// Hue calculation has 3 cases, depending on which RGB component is largest, and one of those cases involves a \\\"mod\\\"\\n\\t// operation. In order to avoid that \\\"mod\\\" we split the M==R case in two: one for G<B and one for B>G. The B>G case\\n\\t// will be calculated in the negative and fed through abs() in the hue calculation at the end.\\n\\t// See also: https://en.wikipedia.org/wiki/HSL_and_HSV#Hue_and_chroma\\n\\tconst vec4 hueOffsets = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n\\n\\t// temp1.xy = sort B & G (largest first)\\n\\t// temp1.z = the hue offset we'll use if it turns out that R is the largest component (M==R)\\n\\t// temp1.w = the hue offset we'll use if it turns out that R is not the largest component (M==G or M==B)\\n\\tvec4 temp1 = rgb.b > rgb.g ? vec4(rgb.bg, hueOffsets.wz) : vec4(rgb.gb, hueOffsets.xy);\\n\\n\\t// temp2.x = the largest component of RGB (\\\"M\\\" / \\\"Max\\\")\\n\\t// temp2.yw = the smaller components of RGB, ordered for the hue calculation (not necessarily sorted by magnitude!)\\n\\t// temp2.z = the hue offset we'll use in the hue calculation\\n\\tvec4 temp2 = rgb.r > temp1.x ? vec4(rgb.r, temp1.yzx) : vec4(temp1.xyw, rgb.r);\\n\\n\\t// m = the smallest component of RGB (\\\"min\\\")\\n\\tfloat m = min(temp2.y, temp2.w);\\n\\n\\t// Chroma = M - m\\n\\tfloat C = temp2.x - m;\\n\\n\\t// Value = M\\n\\tfloat V = temp2.x;\\n\\n\\treturn vec3(\\n\\t\\tabs(temp2.z + (temp2.w - temp2.y) / (6.0 * C + epsilon)), // Hue\\n\\t\\tC / (temp2.x + epsilon), // Saturation\\n\\t\\tV); // Value\\n}\\n\\nvec3 convertHue2RGB(float hue)\\n{\\n\\tfloat r = abs(hue * 6.0 - 3.0) - 1.0;\\n\\tfloat g = 2.0 - abs(hue * 6.0 - 2.0);\\n\\tfloat b = 2.0 - abs(hue * 6.0 - 4.0);\\n\\treturn clamp(vec3(r, g, b), 0.0, 1.0);\\n}\\n\\nvec3 convertHSV2RGB(vec3 hsv)\\n{\\n\\tvec3 rgb = convertHue2RGB(hsv.x);\\n\\tfloat c = hsv.z * hsv.y;\\n\\treturn rgb * c + hsv.z - c;\\n}\\n#endif // !defined(DRAW_MODE_silhouette) && (defined(ENABLE_color) || defined(ENABLE_brightness))\\n\\nconst vec2 kCenter = vec2(0.5, 0.5);\\n\\nvoid main()\\n{\\n\\t#ifndef DRAW_MODE_lineSample\\n\\tvec2 texcoord0 = v_texCoord;\\n\\n\\t#ifdef ENABLE_mosaic\\n\\ttexcoord0 = fract(u_mosaic * texcoord0);\\n\\t#endif // ENABLE_mosaic\\n\\n\\t#ifdef ENABLE_pixelate\\n\\t{\\n\\t\\t// TODO: clean up \\\"pixel\\\" edges\\n\\t\\tvec2 pixelTexelSize = u_skinSize / u_pixelate;\\n\\t\\ttexcoord0 = (floor(texcoord0 * pixelTexelSize) + kCenter) / pixelTexelSize;\\n\\t}\\n\\t#endif // ENABLE_pixelate\\n\\n\\t#ifdef ENABLE_whirl\\n\\t{\\n\\t\\tconst float kRadius = 0.5;\\n\\t\\tvec2 offset = texcoord0 - kCenter;\\n\\t\\tfloat offsetMagnitude = length(offset);\\n\\t\\tfloat whirlFactor = max(1.0 - (offsetMagnitude / kRadius), 0.0);\\n\\t\\tfloat whirlActual = u_whirl * whirlFactor * whirlFactor;\\n\\t\\tfloat sinWhirl = sin(whirlActual);\\n\\t\\tfloat cosWhirl = cos(whirlActual);\\n\\t\\tmat2 rotationMatrix = mat2(\\n\\t\\t\\tcosWhirl, -sinWhirl,\\n\\t\\t\\tsinWhirl, cosWhirl\\n\\t\\t);\\n\\n\\t\\ttexcoord0 = rotationMatrix * offset + kCenter;\\n\\t}\\n\\t#endif // ENABLE_whirl\\n\\n\\t#ifdef ENABLE_fisheye\\n\\t{\\n\\t\\tvec2 vec = (texcoord0 - kCenter) / kCenter;\\n\\t\\tfloat vecLength = length(vec);\\n\\t\\tfloat r = pow(min(vecLength, 1.0), u_fisheye) * max(1.0, vecLength);\\n\\t\\tvec2 unit = vec / vecLength;\\n\\n\\t\\ttexcoord0 = kCenter + r * unit * kCenter;\\n\\t}\\n\\t#endif // ENABLE_fisheye\\n\\n\\tgl_FragColor = texture2D(u_skin, texcoord0);\\n\\n    #ifdef ENABLE_ghost\\n    gl_FragColor.a *= u_ghost;\\n    #endif // ENABLE_ghost\\n\\n\\t#ifdef DRAW_MODE_silhouette\\n\\t// switch to u_silhouetteColor only AFTER the alpha test\\n\\tgl_FragColor = u_silhouetteColor;\\n\\t#else // DRAW_MODE_silhouette\\n\\n\\t#if defined(ENABLE_color) || defined(ENABLE_brightness)\\n\\t{\\n\\t\\tvec3 hsv = convertRGB2HSV(gl_FragColor.xyz);\\n\\n\\t\\t#ifdef ENABLE_color\\n\\t\\t{\\n\\t\\t\\t// this code forces grayscale values to be slightly saturated\\n\\t\\t\\t// so that some slight change of hue will be visible\\n\\t\\t\\tconst float minLightness = 0.11 / 2.0;\\n\\t\\t\\tconst float minSaturation = 0.09;\\n\\t\\t\\tif (hsv.z < minLightness) hsv = vec3(0.0, 1.0, minLightness);\\n\\t\\t\\telse if (hsv.y < minSaturation) hsv = vec3(0.0, minSaturation, hsv.z);\\n\\n\\t\\t\\thsv.x = mod(hsv.x + u_color, 1.0);\\n\\t\\t\\tif (hsv.x < 0.0) hsv.x += 1.0;\\n\\t\\t}\\n\\t\\t#endif // ENABLE_color\\n\\n\\t\\t#ifdef ENABLE_brightness\\n\\t\\thsv.z = clamp(hsv.z + u_brightness, 0.0, 1.0);\\n\\t\\t#endif // ENABLE_brightness\\n\\n\\t\\tgl_FragColor.rgb = convertHSV2RGB(hsv);\\n\\t}\\n\\t#endif // defined(ENABLE_color) || defined(ENABLE_brightness)\\n\\n\\t#ifdef DRAW_MODE_colorMask\\n\\tvec3 maskDistance = abs(gl_FragColor.rgb - u_colorMask);\\n\\tvec3 colorMaskTolerance = vec3(u_colorMaskTolerance, u_colorMaskTolerance, u_colorMaskTolerance);\\n\\tif (any(greaterThan(maskDistance, colorMaskTolerance)))\\n\\t{\\n\\t\\tdiscard;\\n\\t}\\n\\t#endif // DRAW_MODE_colorMask\\n\\n\\t// WebGL defaults to premultiplied alpha\\n\\t#ifndef DRAW_MODE_stamp\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n\\t#endif // DRAW_MODE_stamp\\n\\n\\t#endif // DRAW_MODE_silhouette\\n\\n\\t#else // DRAW_MODE_lineSample\\n\\tgl_FragColor = u_lineColor;\\n\\tgl_FragColor.a *= clamp(\\n\\t\\t// Scale the capScale a little to have an aliased region.\\n\\t\\t(u_capScale + u_aliasAmount -\\n\\t\\t\\tu_capScale * 2.0 * distance(v_texCoord, vec2(0.5, 0.5))\\n\\t\\t) / (u_aliasAmount + 1.0),\\n\\t\\t0.0,\\n\\t\\t1.0\\n\\t);\\n\\t#endif // DRAW_MODE_lineSample\\n}\\n\"","const twgl = require('twgl.js');\n\nconst RenderConstants = require('./RenderConstants');\nconst Skin = require('./Skin');\n\nconst Rectangle = require('./Rectangle');\nconst ShaderManager = require('./ShaderManager');\n\n/**\n * Attributes to use when drawing with the pen\n * @typedef {object} PenSkin#PenAttributes\n * @property {number} [diameter] - The size (diameter) of the pen.\n * @property {Array<number>} [color4f] - The pen color as an array of [r,g,b,a], each component in the range [0,1].\n */\n\n/**\n * The pen attributes to use when unspecified.\n * @type {PenSkin#PenAttributes}\n * @memberof PenSkin\n * @private\n * @const\n */\nconst DefaultPenAttributes = {\n    color4f: [0, 0, 1, 1],\n    diameter: 1\n};\n\n\n/**\n * Reused memory location for projection matrices.\n * @type {FloatArray}\n */\nconst __projectionMatrix = twgl.m4.identity();\n\n/**\n * Reused memory location for translation matrix for building a model matrix.\n * @type {FloatArray}\n */\nconst __modelTranslationMatrix = twgl.m4.identity();\n\n/**\n * Reused memory location for rotation matrix for building a model matrix.\n * @type {FloatArray}\n */\nconst __modelRotationMatrix = twgl.m4.identity();\n\n/**\n * Reused memory location for scaling matrix for building a model matrix.\n * @type {FloatArray}\n */\nconst __modelScalingMatrix = twgl.m4.identity();\n\n/**\n * Reused memory location for a model matrix.\n * @type {FloatArray}\n */\nconst __modelMatrix = twgl.m4.identity();\n\n/**\n * Reused memory location for a vector to create a translation matrix from.\n * @type {FloatArray}\n */\nconst __modelTranslationVector = twgl.v3.create();\n\n/**\n * Reused memory location for a vector to create a scaling matrix from.\n * @type {FloatArray}\n */\nconst __modelScalingVector = twgl.v3.create();\n\nclass PenSkin extends Skin {\n    /**\n     * Create a Skin which implements a Scratch pen layer.\n     * @param {int} id - The unique ID for this Skin.\n     * @param {RenderWebGL} renderer - The renderer which will use this Skin.\n     * @extends Skin\n     * @listens RenderWebGL#event:NativeSizeChanged\n     */\n    constructor (id, renderer) {\n        super(id);\n\n        /**\n         * @private\n         * @type {RenderWebGL}\n         */\n        this._renderer = renderer;\n\n        /** @type {HTMLCanvasElement} */\n        this._canvas = document.createElement('canvas');\n\n        /** @type {WebGLTexture} */\n        this._texture = null;\n\n        /** @type {WebGLTexture} */\n        this._exportTexture = null;\n\n        /** @type {WebGLFramebuffer} */\n        this._framebuffer = null;\n\n        /** @type {WebGLFramebuffer} */\n        this._silhouetteBuffer = null;\n\n        /** @type {boolean} */\n        this._canvasDirty = false;\n\n        /** @type {boolean} */\n        this._silhouetteDirty = false;\n\n        /** @type {object} */\n        this._lineOnBufferDrawRegionId = {\n            enter: () => this._enterDrawLineOnBuffer(),\n            exit: () => this._exitDrawLineOnBuffer()\n        };\n\n        /** @type {object} */\n        this._toBufferDrawRegionId = {\n            enter: () => this._enterDrawToBuffer(),\n            exit: () => this._exitDrawToBuffer()\n        };\n\n        /** @type {twgl.BufferInfo} */\n        this._lineBufferInfo = null;\n\n        const NO_EFFECTS = 0;\n        /** @type {twgl.ProgramInfo} */\n        this._stampShader = this._renderer._shaderManager.getShader(ShaderManager.DRAW_MODE.stamp, NO_EFFECTS);\n\n        /** @type {twgl.ProgramInfo} */\n        this._lineShader = this._renderer._shaderManager.getShader(ShaderManager.DRAW_MODE.lineSample, NO_EFFECTS);\n\n        this._createLineGeometry();\n\n        this.onNativeSizeChanged = this.onNativeSizeChanged.bind(this);\n        this._renderer.on(RenderConstants.Events.NativeSizeChanged, this.onNativeSizeChanged);\n\n        this._setCanvasSize(renderer.getNativeSize());\n    }\n\n    /**\n     * Dispose of this object. Do not use it after calling this method.\n     */\n    dispose () {\n        this._renderer.removeListener(RenderConstants.Events.NativeSizeChanged, this.onNativeSizeChanged);\n        this._renderer.gl.deleteTexture(this._texture);\n        this._renderer.gl.deleteTexture(this._exportTexture);\n        this._texture = null;\n        super.dispose();\n    }\n\n    /**\n     * @returns {boolean} true for a raster-style skin (like a BitmapSkin), false for vector-style (like SVGSkin).\n     */\n    get isRaster () {\n        return true;\n    }\n\n    /**\n     * @return {Array<number>} the \"native\" size, in texels, of this skin. [width, height]\n     */\n    get size () {\n        return [this._canvas.width, this._canvas.height];\n    }\n\n    /**\n     * @return {WebGLTexture} The GL texture representation of this skin when drawing at the given size.\n     * @param {int} pixelsWide - The width that the skin will be rendered at, in GPU pixels.\n     * @param {int} pixelsTall - The height that the skin will be rendered at, in GPU pixels.\n     */\n    // eslint-disable-next-line no-unused-vars\n    getTexture (pixelsWide, pixelsTall) {\n        if (this._canvasDirty) {\n            this._drawToBuffer();\n        }\n\n        return this._exportTexture;\n    }\n\n    /**\n     * Clear the pen layer.\n     */\n    clear () {\n        const gl = this._renderer.gl;\n        twgl.bindFramebufferInfo(gl, this._framebuffer);\n\n        gl.clearColor(1, 1, 1, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        const ctx = this._canvas.getContext('2d');\n        ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\n\n        this._silhouetteDirty = true;\n    }\n\n    /**\n     * Draw a point on the pen layer.\n     * @param {PenAttributes} penAttributes - how the point should be drawn.\n     * @param {number} x - the X coordinate of the point to draw.\n     * @param {number} y - the Y coordinate of the point to draw.\n     */\n    drawPoint (penAttributes, x, y) {\n        // Canvas renders a zero-length line as two end-caps back-to-back, which is what we want.\n        this.drawLine(penAttributes, x, y, x, y);\n    }\n\n    /**\n     * Draw a line on the pen layer.\n     * @param {PenAttributes} penAttributes - how the line should be drawn.\n     * @param {number} x0 - the X coordinate of the beginning of the line.\n     * @param {number} y0 - the Y coordinate of the beginning of the line.\n     * @param {number} x1 - the X coordinate of the end of the line.\n     * @param {number} y1 - the Y coordinate of the end of the line.\n     */\n    drawLine (penAttributes, x0, y0, x1, y1) {\n        this._drawLineOnBuffer(\n            penAttributes,\n            this._rotationCenter[0] + x0, this._rotationCenter[1] - y0,\n            this._rotationCenter[0] + x1, this._rotationCenter[1] - y1\n        );\n\n        this._silhouetteDirty = true;\n    }\n\n    /**\n     * Create 2D geometry for drawing lines to a framebuffer.\n     */\n    _createLineGeometry () {\n        // Create a set of triangulated quads that break up a line into 3 parts:\n        // 2 caps and a body. The y component of these position vertices are\n        // divided to bring a value of 1 down to 0.5 to 0. The large y values\n        // are set so they will still be at least 0.5 after division. The\n        // divisor is scaled based on the length of the line and the lines\n        // width.\n        //\n        // Texture coordinates are based on a \"generated\" texture whose general\n        // shape is a circle. The line caps set their texture values to define\n        // there roundedness with the texture. The body has all of its texture\n        // values set to the center of the texture so it's a solid block.\n        const quads = {\n            a_position: {\n                numComponents: 2,\n                data: [\n                    -0.5, 1,\n                    0.5, 1,\n                    -0.5, 100000,\n\n                    -0.5, 100000,\n                    0.5, 1,\n                    0.5, 100000,\n\n                    -0.5, 1,\n                    0.5, 1,\n                    -0.5, -1,\n\n                    -0.5, -1,\n                    0.5, 1,\n                    0.5, -1,\n\n                    -0.5, -100000,\n                    0.5, -100000,\n                    -0.5, -1,\n\n                    -0.5, -1,\n                    0.5, -100000,\n                    0.5, -1\n                ]\n            },\n            a_texCoord: {\n                numComponents: 2,\n                data: [\n                    1, 0.5,\n                    0, 0.5,\n                    1, 0,\n\n                    1, 0,\n                    0, 0.5,\n                    0, 0,\n\n                    0.5, 0,\n                    0.5, 1,\n                    0.5, 0,\n\n                    0.5, 0,\n                    0.5, 1,\n                    0.5, 1,\n\n                    1, 0,\n                    0, 0,\n                    1, 0.5,\n\n                    1, 0.5,\n                    0, 0,\n                    0, 0.5\n                ]\n            }\n        };\n\n        this._lineBufferInfo = twgl.createBufferInfoFromArrays(this._renderer.gl, quads);\n    }\n\n    /**\n     * Prepare to draw lines in the _lineOnBufferDrawRegionId region.\n     */\n    _enterDrawLineOnBuffer () {\n        const gl = this._renderer.gl;\n\n        const bounds = this._bounds;\n        const currentShader = this._lineShader;\n        const projection = twgl.m4.ortho(0, bounds.width, 0, bounds.height, -1, 1, __projectionMatrix);\n\n        twgl.bindFramebufferInfo(gl, this._framebuffer);\n\n        // Needs a blend function that blends a destination that starts with\n        // no alpha.\n        gl.blendFuncSeparate(\n            gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA,\n            gl.ONE, gl.ONE_MINUS_SRC_ALPHA\n        );\n\n        gl.viewport(0, 0, bounds.width, bounds.height);\n\n        gl.useProgram(currentShader.program);\n\n        twgl.setBuffersAndAttributes(gl, currentShader, this._lineBufferInfo);\n\n        const uniforms = {\n            u_skin: this._texture,\n            u_projectionMatrix: projection,\n            u_fudge: 0\n        };\n\n        twgl.setUniforms(currentShader, uniforms);\n    }\n\n    /**\n     * Return to a base state from _lineOnBufferDrawRegionId.\n     */\n    _exitDrawLineOnBuffer () {\n        const gl = this._renderer.gl;\n\n        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE);\n\n        twgl.bindFramebufferInfo(gl, null);\n    }\n\n    /**\n     * Draw a line on the framebuffer.\n     * @param {PenAttributes} penAttributes - how the line should be drawn.\n     * @param {number} x0 - the X coordinate of the beginning of the line.\n     * @param {number} y0 - the Y coordinate of the beginning of the line.\n     * @param {number} x1 - the X coordinate of the end of the line.\n     * @param {number} y1 - the Y coordinate of the end of the line.\n     */\n    _drawLineOnBuffer (penAttributes, x0, y0, x1, y1) {\n        const gl = this._renderer.gl;\n\n        const currentShader = this._lineShader;\n\n        this._renderer.enterDrawRegion(this._lineOnBufferDrawRegionId);\n\n        const diameter = penAttributes.diameter || DefaultPenAttributes.diameter;\n        const length = Math.hypot(Math.abs(x1 - x0) - 0.001, Math.abs(y1 - y0) - 0.001);\n        const avgX = (x0 + x1) / 2;\n        const avgY = (y0 + y1) / 2;\n        const theta = Math.atan2(y0 - y1, x0 - x1);\n        const alias = 1;\n\n        // The line needs a bit of aliasing to look smooth. Add a small offset\n        // and a small size boost to scaling to give a section to alias.\n        const translationVector = __modelTranslationVector;\n        translationVector[0] = avgX - (alias / 2);\n        translationVector[1] = avgY + (alias / 4);\n\n        const scalingVector = __modelScalingVector;\n        scalingVector[0] = diameter + alias;\n        scalingVector[1] = length + diameter - (alias / 2);\n\n        const radius = diameter / 2;\n        const yScalar = (0.50001 - (radius / (length + diameter)));\n\n        const uniforms = {\n            u_positionScalar: yScalar,\n            u_capScale: diameter,\n            u_aliasAmount: alias,\n            u_modelMatrix: twgl.m4.multiply(\n                twgl.m4.multiply(\n                    twgl.m4.translation(translationVector, __modelTranslationMatrix),\n                    twgl.m4.rotationZ(theta - (Math.PI / 2), __modelRotationMatrix),\n                    __modelMatrix\n                ),\n                twgl.m4.scaling(scalingVector, __modelScalingMatrix),\n                __modelMatrix\n            ),\n            u_lineColor: penAttributes.color4f || DefaultPenAttributes.color4f\n        };\n\n        twgl.setUniforms(currentShader, uniforms);\n\n        twgl.drawBufferInfo(gl, this._lineBufferInfo, gl.TRIANGLES);\n\n        this._silhouetteDirty = true;\n    }\n\n    /**\n     * Stamp an image onto the pen layer.\n     * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} stampElement - the element to use as the stamp.\n     * @param {number} x - the X coordinate of the stamp to draw.\n     * @param {number} y - the Y coordinate of the stamp to draw.\n     */\n    drawStamp (stampElement, x, y) {\n        const ctx = this._canvas.getContext('2d');\n\n        ctx.drawImage(stampElement, this._rotationCenter[0] + x, this._rotationCenter[1] - y);\n\n        this._canvasDirty = true;\n        this._silhouetteDirty = true;\n    }\n\n    /**\n     * Enter a draw region to draw a rectangle.\n     *\n     * Multiple calls with the same regionId skip the callback reducing the\n     * amount of GL state changes.\n     * @param {twgl.ProgramInfo} currentShader - program info to draw rectangle\n     *   with\n     * @param {Rectangle} bounds - viewport bounds to draw in\n     *   region\n     */\n    _drawRectangleRegionEnter (currentShader, bounds) {\n        const gl = this._renderer.gl;\n\n        gl.viewport(0, 0, bounds.width, bounds.height);\n\n        gl.useProgram(currentShader.program);\n        twgl.setBuffersAndAttributes(gl, currentShader, this._renderer._bufferInfo);\n    }\n\n    /**\n     * Draw a rectangle.\n     * @param {twgl.ProgramInfo} currentShader - program info to draw rectangle\n     *   with\n     * @param {WebGLTexture} texture - texture to draw\n     * @param {Rectangle} bounds - bounded area to draw in\n     * @param {number} x - centered at x\n     * @param {number} y - centered at y\n     */\n    _drawRectangle (currentShader, texture, bounds, x = -this._canvas.width / 2, y = this._canvas.height / 2) {\n        const gl = this._renderer.gl;\n\n        const projection = twgl.m4.ortho(\n            bounds.left, bounds.right, bounds.top, bounds.bottom, -1, 1,\n            __projectionMatrix\n        );\n\n        const uniforms = {\n            u_skin: texture,\n            u_projectionMatrix: projection,\n            u_modelMatrix: twgl.m4.multiply(\n                twgl.m4.translation(twgl.v3.create(\n                    -x - (bounds.width / 2),\n                    -y + (bounds.height / 2),\n                    0\n                ), __modelTranslationMatrix),\n                twgl.m4.scaling(twgl.v3.create(\n                    bounds.width,\n                    bounds.height,\n                    0\n                ), __modelScalingMatrix),\n                __modelMatrix\n            ),\n            u_fudge: 0\n        };\n\n        twgl.setTextureParameters(gl, texture, {minMag: gl.NEAREST});\n        twgl.setUniforms(currentShader, uniforms);\n\n        twgl.drawBufferInfo(gl, this._renderer._bufferInfo, gl.TRIANGLES);\n    }\n\n    /**\n     * Prepare to draw a rectangle in the _toBufferDrawRegionId region.\n     */\n    _enterDrawToBuffer () {\n        const gl = this._renderer.gl;\n\n        twgl.bindFramebufferInfo(gl, this._framebuffer);\n\n        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n        this._drawRectangleRegionEnter(this._stampShader, this._bounds);\n    }\n\n    /**\n     * Return to a base state from _toBufferDrawRegionId.\n     */\n    _exitDrawToBuffer () {\n        const gl = this._renderer.gl;\n\n        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE);\n\n        twgl.bindFramebufferInfo(gl, null);\n    }\n\n    /**\n     * Draw the input texture to the framebuffer.\n     * @param {WebGLTexture} texture - input texture to draw\n     * @param {number} x - texture centered at x\n     * @param {number} y - texture centered at y\n     */\n    _drawToBuffer (texture = this._texture, x = -this._canvas.width / 2, y = this._canvas.height / 2) {\n        if (texture !== this._texture && this._canvasDirty) {\n            this._drawToBuffer();\n        }\n\n        const gl = this._renderer.gl;\n\n        // If the input texture is the one that represents the pen's canvas\n        // layer, update the texture with the canvas data.\n        if (texture === this._texture) {\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._canvas);\n\n            const ctx = this._canvas.getContext('2d');\n            ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\n\n            this._canvasDirty = false;\n        }\n\n        const currentShader = this._stampShader;\n        const bounds = this._bounds;\n\n        this._renderer.enterDrawRegion(this._toBufferDrawRegionId);\n\n        this._drawRectangle(currentShader, texture, bounds, x, y);\n\n        this._silhouetteDirty = true;\n    }\n\n    /**\n     * React to a change in the renderer's native size.\n     * @param {object} event - The change event.\n     */\n    onNativeSizeChanged (event) {\n        this._setCanvasSize(event.newSize);\n    }\n\n    /**\n     * Set the size of the pen canvas.\n     * @param {Array<int>} canvasSize - the new width and height for the canvas.\n     * @private\n     */\n    _setCanvasSize (canvasSize) {\n        const [width, height] = canvasSize;\n\n        const gl = this._renderer.gl;\n\n        this._bounds = new Rectangle();\n        this._bounds.initFromBounds(width / 2, width / -2, height / 2, height / -2);\n\n        this._canvas.width = width;\n        this._canvas.height = height;\n        this._rotationCenter[0] = width / 2;\n        this._rotationCenter[1] = height / 2;\n\n        this._texture = twgl.createTexture(\n            gl,\n            {\n                auto: true,\n                mag: gl.NEAREST,\n                min: gl.NEAREST,\n                wrap: gl.CLAMP_TO_EDGE,\n                src: this._canvas\n            }\n        );\n\n        this._exportTexture = twgl.createTexture(\n            gl,\n            {\n                auto: true,\n                mag: gl.NEAREST,\n                min: gl.NEAREST,\n                wrap: gl.CLAMP_TO_EDGE,\n                width,\n                height\n            }\n        );\n\n        const attachments = [\n            {\n                format: gl.RGBA,\n                attachment: this._exportTexture\n            }\n        ];\n        if (this._framebuffer) {\n            twgl.resizeFramebufferInfo(gl, this._framebuffer, attachments, width, height);\n            twgl.resizeFramebufferInfo(gl, this._silhouetteBuffer, [{format: gl.RGBA}], width, height);\n        } else {\n            this._framebuffer = twgl.createFramebufferInfo(gl, attachments, width, height);\n            this._silhouetteBuffer = twgl.createFramebufferInfo(gl, [{format: gl.RGBA}], width, height);\n        }\n\n        gl.clearColor(1, 1, 1, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        this._silhouetteDirty = true;\n    }\n\n    /**\n     * Set context state to match provided pen attributes.\n     * @param {CanvasRenderingContext2D} context - the canvas rendering context to be modified.\n     * @param {PenAttributes} penAttributes - the pen attributes to be used.\n     * @private\n     */\n    _setAttributes (context, penAttributes) {\n        penAttributes = penAttributes || DefaultPenAttributes;\n        const color4f = penAttributes.color4f || DefaultPenAttributes.color4f;\n        const diameter = penAttributes.diameter || DefaultPenAttributes.diameter;\n\n        const r = Math.round(color4f[0] * 255);\n        const g = Math.round(color4f[1] * 255);\n        const b = Math.round(color4f[2] * 255);\n        const a = color4f[3]; // Alpha is 0 to 1 (not 0 to 255 like r,g,b)\n\n        context.strokeStyle = `rgba(${r},${g},${b},${a})`;\n        context.lineCap = 'round';\n        context.lineWidth = diameter;\n    }\n\n    /**\n     * If there have been pen operations that have dirtied the canvas, update\n     * now before someone wants to use our silhouette.\n     */\n    updateSilhouette () {\n        if (this._silhouetteDirty) {\n            if (this._canvasDirty) {\n                this._drawToBuffer();\n            }\n\n            // Render export texture to another framebuffer\n            const gl = this._renderer.gl;\n\n            const bounds = this._bounds;\n\n            this._renderer.enterDrawRegion(this._toBufferDrawRegionId);\n\n            // Sample the framebuffer's pixels into the silhouette instance\n            const skinPixels = new Uint8Array(Math.floor(this._canvas.width * this._canvas.height * 4));\n            gl.readPixels(0, 0, this._canvas.width, this._canvas.height, gl.RGBA, gl.UNSIGNED_BYTE, skinPixels);\n\n            const skinCanvas = this._canvas;\n            skinCanvas.width = bounds.width;\n            skinCanvas.height = bounds.height;\n\n            const skinContext = skinCanvas.getContext('2d');\n            const skinImageData = skinContext.createImageData(bounds.width, bounds.height);\n            skinImageData.data.set(skinPixels);\n            skinContext.putImageData(skinImageData, 0, 0);\n\n            this._silhouette.update(this._canvas);\n\n            this._silhouetteDirty = false;\n        }\n    }\n}\n\nmodule.exports = PenSkin;\n","const twgl = require('twgl.js');\n\nconst Skin = require('./Skin');\nconst SvgRenderer = require('scratch-svg-renderer').SVGRenderer;\n\nconst MAX_TEXTURE_DIMENSION = 2048;\n\nclass SVGSkin extends Skin {\n    /**\n     * Create a new SVG skin.\n     * @param {!int} id - The ID for this Skin.\n     * @param {!RenderWebGL} renderer - The renderer which will use this skin.\n     * @constructor\n     * @extends Skin\n     */\n    constructor (id, renderer) {\n        super(id);\n\n        /** @type {RenderWebGL} */\n        this._renderer = renderer;\n\n        /** @type {SvgRenderer} */\n        this._svgRenderer = new SvgRenderer();\n\n        /** @type {WebGLTexture} */\n        this._texture = null;\n\n        /** @type {number} */\n        this._textureScale = 1;\n\n        /** @type {Number} */\n        this._maxTextureScale = 0;\n    }\n\n    /**\n     * Dispose of this object. Do not use it after calling this method.\n     */\n    dispose () {\n        if (this._texture) {\n            this._renderer.gl.deleteTexture(this._texture);\n            this._texture = null;\n        }\n        super.dispose();\n    }\n\n    /**\n     * @return {Array<number>} the natural size, in Scratch units, of this skin.\n     */\n    get size () {\n        return this._svgRenderer.size;\n    }\n\n    /**\n     * Set the origin, in object space, about which this Skin should rotate.\n     * @param {number} x - The x coordinate of the new rotation center.\n     * @param {number} y - The y coordinate of the new rotation center.\n     */\n    setRotationCenter (x, y) {\n        const viewOffset = this._svgRenderer.viewOffset;\n        super.setRotationCenter(x - viewOffset[0], y - viewOffset[1]);\n    }\n\n    /**\n     * @param {Array<number>} scale - The scaling factors to be used, each in the [0,100] range.\n     * @return {WebGLTexture} The GL texture representation of this skin when drawing at the given scale.\n     */\n    // eslint-disable-next-line no-unused-vars\n    getTexture (scale) {\n        // The texture only ever gets uniform scale. Take the larger of the two axes.\n        const scaleMax = scale ? Math.max(Math.abs(scale[0]), Math.abs(scale[1])) : 100;\n        const requestedScale = Math.min(scaleMax / 100, this._maxTextureScale);\n        let newScale = this._textureScale;\n        while ((newScale < this._maxTextureScale) && (requestedScale >= 1.5 * newScale)) {\n            newScale *= 2;\n        }\n        if (this._textureScale !== newScale) {\n            this._textureScale = newScale;\n            this._svgRenderer._draw(this._textureScale, () => {\n                if (this._textureScale === newScale) {\n                    const gl = this._renderer.gl;\n                    gl.bindTexture(gl.TEXTURE_2D, this._texture);\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._svgRenderer.canvas);\n                }\n            });\n        }\n\n        return this._texture;\n    }\n\n    /**\n     * Set the contents of this skin to a snapshot of the provided SVG data.\n     * @param {string} svgData - new SVG to use.\n     * @param {Array<number>} [rotationCenter] - Optional rotation center for the SVG. If not supplied, it will be\n     * calculated from the bounding box\n     * @fires Skin.event:WasAltered\n     */\n    setSVG (svgData, rotationCenter) {\n        this._svgRenderer.fromString(svgData, 1, () => {\n            const gl = this._renderer.gl;\n            this._textureScale = this._maxTextureScale = 1;\n            if (this._texture) {\n                gl.bindTexture(gl.TEXTURE_2D, this._texture);\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._svgRenderer.canvas);\n                this._silhouette.update(this._svgRenderer.canvas);\n            } else {\n                // TODO: mipmaps?\n                const textureOptions = {\n                    auto: true,\n                    wrap: gl.CLAMP_TO_EDGE,\n                    src: this._svgRenderer.canvas\n                };\n\n                this._texture = twgl.createTexture(gl, textureOptions);\n                this._silhouette.update(this._svgRenderer.canvas);\n            }\n\n            const maxDimension = Math.max(this._svgRenderer.canvas.width, this._svgRenderer.canvas.height);\n            let testScale = 2;\n            for (testScale; maxDimension * testScale <= MAX_TEXTURE_DIMENSION; testScale *= 2) {\n                this._maxTextureScale = testScale;\n            }\n\n            if (typeof rotationCenter === 'undefined') rotationCenter = this.calculateRotationCenter();\n            this.setRotationCenter.apply(this, rotationCenter);\n            this.emit(Skin.Events.WasAltered);\n        });\n    }\n\n}\n\nmodule.exports = SVGSkin;\n","const SVGTextWrapper = require('./svg-text-wrapper');\nconst SvgRenderer = require('scratch-svg-renderer').SVGRenderer;\n\nconst MAX_LINE_LENGTH = 170;\nconst MIN_WIDTH = 50;\nconst STROKE_WIDTH = 4;\n\nclass SVGTextBubble {\n    constructor () {\n        this.svgRenderer = new SvgRenderer();\n        this.svgTextWrapper = new SVGTextWrapper(this.makeSvgTextElement);\n        this._textSizeCache = {};\n    }\n\n    /**\n     * @return {SVGElement} an SVG text node with the properties that we want for speech bubbles.\n     */\n    makeSvgTextElement () {\n        const svgText = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n        svgText.setAttribute('alignment-baseline', 'text-before-edge');\n        svgText.setAttribute('font-size', '14');\n        svgText.setAttribute('fill', '#575E75');\n        // TODO Do we want to use the new default sans font instead of Helvetica?\n        svgText.setAttribute('font-family', 'Helvetica');\n        return svgText;\n    }\n\n    _speechBubble (w, h, radius, pointsLeft) {\n        let pathString = `\n            M 0 ${radius}\n            A ${radius} ${radius} 0 0 1 ${radius} 0\n            L ${w - radius} 0\n            A ${radius} ${radius} 0 0 1 ${w} ${radius}\n            L ${w} ${h - radius}\n            A ${radius} ${radius} 0 0 1 ${w - radius} ${h}`;\n\n        if (pointsLeft) {\n            pathString += `\n                L 32 ${h}\n                c -5 8 -15 12 -18 12\n                a 2 2 0 0 1 -2 -2\n                c 0 -2 4 -6 4 -10`;\n        } else {\n            pathString += `\n                L ${w - 16} ${h}\n                c 0 4 4 8 4 10\n                a 2 2 0 0 1 -2 2\n                c -3 0 -13 -4 -18 -12`;\n        }\n\n        pathString += `\n            L ${radius} ${h}\n            A ${radius} ${radius} 0 0 1 0 ${h - radius}\n            Z`;\n\n        return `\n            <g>\n                <path\n                  d=\"${pathString}\"\n                  stroke=\"rgba(0, 0, 0, 0.15)\"\n                  stroke-width=\"${STROKE_WIDTH}\"\n                  fill=\"rgba(0, 0, 0, 0.15)\"\n                  stroke-line-join=\"round\"\n              />\n              <path\n                d=\"${pathString}\"\n                stroke=\"none\"\n                fill=\"white\" />\n            </g>`;\n    }\n\n    _thinkBubble (w, h, radius, pointsLeft) {\n        const e1rx = 2.25;\n        const e1ry = 2.25;\n        const e2rx = 1.5;\n        const e2ry = 1.5;\n        const e1x = 16 + 7 + e1rx;\n        const e1y = 5 + h + e1ry;\n        const e2x = 16 + e2rx;\n        const e2y = 8 + h + e2ry;\n        const insetR = 4;\n        const pInset1 = 12 + radius;\n        const pInset2 = pInset1 + (2 * insetR);\n\n        let pathString = `\n            M 0 ${radius}\n            A ${radius} ${radius} 0 0 1 ${radius} 0\n            L ${w - radius} 0\n            A ${radius} ${radius} 0 0 1 ${w} ${radius}\n            L ${w} ${h - radius}\n            A ${radius} ${radius} 0 0 1 ${w - radius} ${h}`;\n\n        if (pointsLeft) {\n            pathString += `\n                L ${pInset2} ${h}\n                A ${insetR} ${insetR} 0 0 1 ${pInset2 - insetR} ${h + insetR}\n                A ${insetR} ${insetR} 0 0 1 ${pInset1} ${h}`;\n        } else {\n            pathString += `\n                L ${w - pInset1} ${h}\n                A ${insetR} ${insetR} 0 0 1 ${w - pInset1 - insetR} ${h + insetR}\n                A ${insetR} ${insetR} 0 0 1 ${w - pInset2} ${h}`;\n        }\n\n        pathString += `\n            L ${radius} ${h}\n            A ${radius} ${radius} 0 0 1 0 ${h - radius}\n            Z`;\n\n        const ellipseSvg = (cx, cy, rx, ry) => `\n            <g>\n                <ellipse\n                    cx=\"${cx}\" cy=\"${cy}\"\n                    rx=\"${rx}\" ry=\"${ry}\"\n                    fill=\"rgba(0, 0, 0, 0.15)\"\n                    stroke=\"rgba(0, 0, 0, 0.15)\"\n                    stroke-width=\"${STROKE_WIDTH}\"\n                />\n                <ellipse\n                    cx=\"${cx}\" cy=\"${cy}\"\n                    rx=\"${rx}\" ry=\"${ry}\"\n                    fill=\"white\"\n                    stroke=\"none\"\n                />\n            </g>`;\n        let ellipses = [];\n        if (pointsLeft) {\n            ellipses = [\n                ellipseSvg(e1x, e1y, e1rx, e1ry),\n                ellipseSvg(e2x, e2y, e2rx, e2ry)\n            ];\n        } else {\n            ellipses = [\n                ellipseSvg(w - e1x, e1y, e1rx, e1ry),\n                ellipseSvg(w - e2x, e2y, e2rx, e2ry)\n            ];\n        }\n\n        return `\n             <g>\n                <path d=\"${pathString}\" stroke=\"rgba(0, 0, 0, 0.15)\" stroke-width=\"${STROKE_WIDTH}\"\n                    fill=\"rgba(0, 0, 0, 0.15)\" />\n                <path d=\"${pathString}\" stroke=\"none\" fill=\"white\" />\n                ${ellipses.join('\\n')}\n            </g>`;\n    }\n\n    _getTextSize (textFragment) {\n        const svgString = this._wrapSvgFragment(textFragment);\n        if (!this._textSizeCache[svgString]) {\n            this._textSizeCache[svgString] = this.svgRenderer.measure(svgString);\n            if (this._textSizeCache[svgString].height === 0) {\n                // The speech bubble is empty, so use the height of a single line with content (or else it renders\n                // weirdly, see issue #302).\n                const dummyFragment = this._buildTextFragment('X');\n                this._textSizeCache[svgString] = this._getTextSize(dummyFragment);\n            }\n        }\n        return this._textSizeCache[svgString];\n    }\n\n    _wrapSvgFragment (fragment, width, height) {\n        let svgString = `<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"`;\n        if (width && height) {\n            const fullWidth = width + STROKE_WIDTH;\n            const fullHeight = height + STROKE_WIDTH + 12;\n            svgString = `${svgString} viewBox=\"\n                ${-STROKE_WIDTH / 2} ${-STROKE_WIDTH / 2} ${fullWidth} ${fullHeight}\"\n                width=\"${fullWidth}\" height=\"${fullHeight}\">`;\n        } else {\n            svgString = `${svgString}>`;\n        }\n        svgString = `${svgString} ${fragment} </svg>`;\n        return svgString;\n    }\n\n    _buildTextFragment (text) {\n        const textNode = this.svgTextWrapper.wrapText(MAX_LINE_LENGTH, text);\n        const serializer = new XMLSerializer();\n        return serializer.serializeToString(textNode);\n    }\n\n    buildString (type, text, pointsLeft) {\n        this.type = type;\n        this.pointsLeft = pointsLeft;\n        this._textFragment = this._buildTextFragment(text);\n\n        let fragment = '';\n\n        const radius = 16;\n        const {x, y, width, height} = this._getTextSize(this._textFragment);\n        const padding = 10;\n        const fullWidth = Math.max(MIN_WIDTH, width) + (2 * padding);\n        const fullHeight = height + (2 * padding);\n        if (this.type === 'say') {\n            fragment += this._speechBubble(fullWidth, fullHeight, radius, this.pointsLeft);\n        } else {\n            fragment += this._thinkBubble(fullWidth, fullHeight, radius, this.pointsLeft);\n        }\n        fragment += `<g transform=\"translate(${padding - x}, ${padding - y})\">${this._textFragment}</g>`;\n        return this._wrapSvgFragment(fragment, fullWidth, fullHeight);\n    }\n}\n\nmodule.exports = SVGTextBubble;\n","const TextWrapper = require('./text-wrapper');\n\n/**\n * Measure text by using a hidden SVG attached to the DOM.\n * For use with TextWrapper.\n */\nclass SVGMeasurementProvider {\n    /**\n     * @param {function} makeTextElement - provides a text node of an SVGElement\n     *     with the style of the text to be wrapped.\n     */\n    constructor (makeTextElement) {\n        this._svgRoot = null;\n        this._cache = {};\n        this.makeTextElement = makeTextElement;\n    }\n\n    /**\n     * Detach the hidden SVG element from the DOM and forget all references to it and its children.\n     */\n    dispose () {\n        if (this._svgRoot) {\n            this._svgRoot.parentElement.removeChild(this._svgRoot);\n            this._svgRoot = null;\n            this._svgText = null;\n        }\n    }\n\n    /**\n     * Called by the TextWrapper before a batch of zero or more calls to measureText().\n     */\n    beginMeasurementSession () {\n        if (!this._svgRoot) {\n            this._init();\n        }\n    }\n\n    /**\n     * Called by the TextWrapper after a batch of zero or more calls to measureText().\n     */\n    endMeasurementSession () {\n        this._svgText.textContent = '';\n        this.dispose();\n    }\n\n    /**\n     * Measure a whole string as one unit.\n     * @param {string} text - the text to measure.\n     * @returns {number} - the length of the string.\n     */\n    measureText (text) {\n        if (!this._cache[text]) {\n            this._svgText.textContent = text;\n            this._cache[text] = this._svgText.getComputedTextLength();\n        }\n        return this._cache[text];\n    }\n\n    /**\n     * Create a simple SVG containing a text node, hide it, and attach it to the DOM. The text node will be used to\n     * collect text measurements. The SVG must be attached to the DOM: otherwise measurements will generally be zero.\n     * @private\n     */\n    _init () {\n        const svgNamespace = 'http://www.w3.org/2000/svg';\n\n        const svgRoot = document.createElementNS(svgNamespace, 'svg');\n        const svgGroup = document.createElementNS(svgNamespace, 'g');\n        const svgText = this.makeTextElement();\n\n        // hide from the user, including screen readers\n        svgRoot.setAttribute('style', 'position:absolute;visibility:hidden');\n\n        document.body.appendChild(svgRoot);\n        svgRoot.appendChild(svgGroup);\n        svgGroup.appendChild(svgText);\n\n        /**\n         * The root SVG element.\n         * @type {SVGSVGElement}\n         * @private\n         */\n        this._svgRoot = svgRoot;\n\n        /**\n         * The leaf SVG element used for text measurement.\n         * @type {SVGTextElement}\n         * @private\n         */\n        this._svgText = svgText;\n    }\n}\n\n/**\n * TextWrapper specialized for SVG text.\n */\nclass SVGTextWrapper extends TextWrapper {\n    /**\n     * @param {function} makeTextElement - provides a text node of an SVGElement\n     *     with the style of the text to be wrapped.\n     */\n    constructor (makeTextElement) {\n        super(new SVGMeasurementProvider(makeTextElement));\n        this.makeTextElement = makeTextElement;\n    }\n\n    /**\n     * Wrap the provided text into lines restricted to a maximum width. See Unicode Standard Annex (UAX) #14.\n     * @param {number} maxWidth - the maximum allowed width of a line.\n     * @param {string} text - the text to be wrapped. Will be split on whitespace.\n     * @returns {SVGElement} wrapped text node\n     */\n    wrapText (maxWidth, text) {\n        const lines = super.wrapText(maxWidth, text);\n        const textElement = this.makeTextElement();\n        for (const line of lines) {\n            const tspanNode = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');\n            tspanNode.setAttribute('x', '0');\n            tspanNode.setAttribute('dy', '1.2em');\n            tspanNode.textContent = line;\n            textElement.appendChild(tspanNode);\n        }\n        return textElement;\n    }\n}\n\nmodule.exports = SVGTextWrapper;\n","const LineBreaker = require('!ify-loader!linebreak');\nconst GraphemeBreaker = require('!ify-loader!grapheme-breaker');\n\n/**\n * Tell this text wrapper to use a specific measurement provider.\n * @typedef {object} MeasurementProvider - the new measurement provider.\n * @property {Function} beginMeasurementSession - this will be called before a batch of measurements are made.\n *      Optionally, this function may return an object to be provided to the endMeasurementSession function.\n * @property {Function} measureText - this will be called each time a piece of text must be measured.\n * @property {Function} endMeasurementSession - this will be called after a batch of measurements is finished.\n *      It will be passed whatever value beginMeasurementSession returned, if any.\n */\n\n/**\n * Utility to wrap text across several lines, respecting Unicode grapheme clusters and, when possible, Unicode line\n * break opportunities.\n * Reference material:\n * - Unicode Standard Annex #14: http://unicode.org/reports/tr14/\n * - Unicode Standard Annex #39: http://unicode.org/reports/tr29/\n * - \"JavaScript has a Unicode problem\" by Mathias Bynens: https://mathiasbynens.be/notes/javascript-unicode\n */\nclass TextWrapper {\n    /**\n     * Construct a text wrapper which will measure text using the specified measurement provider.\n     * @param {MeasurementProvider} measurementProvider - a helper object to provide text measurement services.\n     */\n    constructor (measurementProvider) {\n        this._measurementProvider = measurementProvider;\n        this._cache = {};\n    }\n\n    /**\n     * Wrap the provided text into lines restricted to a maximum width. See Unicode Standard Annex (UAX) #14.\n     * @param {number} maxWidth - the maximum allowed width of a line.\n     * @param {string} text - the text to be wrapped. Will be split on whitespace.\n     * @returns {Array.<string>} an array containing the wrapped lines of text.\n     */\n    wrapText (maxWidth, text) {\n        // Normalize to canonical composition (see Unicode Standard Annex (UAX) #15)\n        text = text.normalize();\n\n        const cacheKey = `${maxWidth}-${text}`;\n        if (this._cache[cacheKey]) {\n            return this._cache[cacheKey];\n        }\n\n        const measurementSession = this._measurementProvider.beginMeasurementSession();\n\n        const breaker = new LineBreaker(text);\n        let lastPosition = 0;\n        let nextBreak;\n        let currentLine = null;\n        const lines = [];\n\n        while ((nextBreak = breaker.nextBreak())) {\n            const word = text.slice(lastPosition, nextBreak.position).replace(/\\n+$/, '');\n\n            let proposedLine = (currentLine || '').concat(word);\n            let proposedLineWidth = this._measurementProvider.measureText(proposedLine);\n\n            if (proposedLineWidth > maxWidth) {\n                // The next word won't fit on this line. Will it fit on a line by itself?\n                const wordWidth = this._measurementProvider.measureText(word);\n                if (wordWidth > maxWidth) {\n                    // The next word can't even fit on a line by itself. Consume it one grapheme cluster at a time.\n                    let lastCluster = 0;\n                    let nextCluster;\n                    while (lastCluster !== (nextCluster = GraphemeBreaker.nextBreak(word, lastCluster))) {\n                        const cluster = word.substring(lastCluster, nextCluster);\n                        proposedLine = (currentLine || '').concat(cluster);\n                        proposedLineWidth = this._measurementProvider.measureText(proposedLine);\n                        if ((currentLine === null) || (proposedLineWidth <= maxWidth)) {\n                            // first cluster of a new line or the cluster fits\n                            currentLine = proposedLine;\n                        } else {\n                            // no more can fit\n                            lines.push(currentLine);\n                            currentLine = cluster;\n                        }\n                        lastCluster = nextCluster;\n                    }\n                } else {\n                    // The next word can fit on the next line. Finish the current line and move on.\n                    if (currentLine !== null) lines.push(currentLine);\n                    currentLine = word;\n                }\n            } else {\n                // The next word fits on this line. Just keep going.\n                currentLine = proposedLine;\n            }\n\n            // Did we find a \\n or similar?\n            if (nextBreak.required) {\n                if (currentLine !== null) lines.push(currentLine);\n                currentLine = null;\n            }\n\n            lastPosition = nextBreak.position;\n        }\n\n        currentLine = currentLine || '';\n        if (currentLine.length > 0 || lines.length === 0) {\n            lines.push(currentLine);\n        }\n\n        this._cache[cacheKey] = lines;\n        this._measurementProvider.endMeasurementSession(measurementSession);\n        return lines;\n    }\n}\n\nmodule.exports = TextWrapper;\n","module.exports = require(\"linebreak\");","module.exports = require(\"grapheme-breaker\");","const minilog = require('minilog');\nminilog.enable();\n\nmodule.exports = minilog('scratch-render');\n","module.exports = require('./common/minilog.js');\n\nvar consoleLogger = require('./node/console.js');\n\n// if we are running inside Electron then use the web version of console.js\nvar isElectron = (typeof window !== 'undefined' && window.process && window.process.type === 'renderer');\nif (isElectron) {\n  consoleLogger = require('./web/console.js').minilog;\n}\n\n// intercept the pipe method and transparently wrap the stringifier, if the\n// destination is a Node core stream\n\nmodule.exports.Stringifier = require('./node/stringify.js');\n\nvar oldPipe = module.exports.pipe;\nmodule.exports.pipe = function(dest) {\n  if(dest instanceof require('stream')) {\n    return oldPipe.call(module.exports, new (module.exports.Stringifier)).pipe(dest);\n  } else {\n    return oldPipe.call(module.exports, dest);\n  }\n};\n\nmodule.exports.defaultBackend = consoleLogger;\nmodule.exports.defaultFormatter = consoleLogger.formatMinilog;\n\nmodule.exports.backends = {\n  redis: require('./node/redis.js'),\n  nodeConsole: consoleLogger,\n  console: consoleLogger\n};\n","function M() { this._events = {}; }\nM.prototype = {\n  on: function(ev, cb) {\n    this._events || (this._events = {});\n    var e = this._events;\n    (e[ev] || (e[ev] = [])).push(cb);\n    return this;\n  },\n  removeListener: function(ev, cb) {\n    var e = this._events[ev] || [], i;\n    for(i = e.length-1; i >= 0 && e[i]; i--){\n      if(e[i] === cb || e[i].cb === cb) { e.splice(i, 1); }\n    }\n  },\n  removeAllListeners: function(ev) {\n    if(!ev) { this._events = {}; }\n    else { this._events[ev] && (this._events[ev] = []); }\n  },\n  listeners: function(ev) {\n    return (this._events ? this._events[ev] || [] : []);\n  },\n  emit: function(ev) {\n    this._events || (this._events = {});\n    var args = Array.prototype.slice.call(arguments, 1), i, e = this._events[ev] || [];\n    for(i = e.length-1; i >= 0 && e[i]; i--){\n      e[i].apply(this, args);\n    }\n    return this;\n  },\n  when: function(ev, cb) {\n    return this.once(ev, cb, true);\n  },\n  once: function(ev, cb, when) {\n    if(!cb) return this;\n    function c() {\n      if(!when) this.removeListener(ev, c);\n      if(cb.apply(this, arguments) && when) this.removeListener(ev, c);\n    }\n    c.cb = cb;\n    this.on(ev, c);\n    return this;\n  }\n};\nM.mixin = function(dest) {\n  var o = M.prototype, k;\n  for (k in o) {\n    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);\n  }\n};\nmodule.exports = M;\n","// default filter\nvar Transform = require('./transform.js');\n\nvar levelMap = { debug: 1, info: 2, warn: 3, error: 4 };\n\nfunction Filter() {\n  this.enabled = true;\n  this.defaultResult = true;\n  this.clear();\n}\n\nTransform.mixin(Filter);\n\n// allow all matching, with level >= given level\nFilter.prototype.allow = function(name, level) {\n  this._white.push({ n: name, l: levelMap[level] });\n  return this;\n};\n\n// deny all matching, with level <= given level\nFilter.prototype.deny = function(name, level) {\n  this._black.push({ n: name, l: levelMap[level] });\n  return this;\n};\n\nFilter.prototype.clear = function() {\n  this._white = [];\n  this._black = [];\n  return this;\n};\n\nfunction test(rule, name) {\n  // use .test for RegExps\n  return (rule.n.test ? rule.n.test(name) : rule.n == name);\n};\n\nFilter.prototype.test = function(name, level) {\n  var i, len = Math.max(this._white.length, this._black.length);\n  for(i = 0; i < len; i++) {\n    if(this._white[i] && test(this._white[i], name) && levelMap[level] >= this._white[i].l) {\n      return true;\n    }\n    if(this._black[i] && test(this._black[i], name) && levelMap[level] <= this._black[i].l) {\n      return false;\n    }\n  }\n  return this.defaultResult;\n};\n\nFilter.prototype.write = function(name, level, args) {\n  if(!this.enabled || this.test(name, level)) {\n    return this.emit('item', name, level, args);\n  }\n};\n\nmodule.exports = Filter;\n","var Transform = require('../common/transform.js');\n\nfunction ConsoleBackend() { }\n\nTransform.mixin(ConsoleBackend);\n\nConsoleBackend.prototype.write = function() {\n  console.log.apply(console, arguments);\n};\n\nvar e = new ConsoleBackend();\n\nvar levelMap = require('./formatters/util.js').levelMap;\n\ne.filterEnv = function() {\n  console.error('Minilog.backends.console.filterEnv is deprecated in Minilog v2.');\n  // return the instance of Minilog\n  return require('../common/minilog.js');\n};\n\ne.formatters = [\n    'formatClean', 'formatColor', 'formatNpm',\n    'formatLearnboost', 'formatMinilog', 'formatWithStack', 'formatTime'\n];\n\ne.formatClean = new (require('./formatters/clean.js'));\ne.formatColor = new (require('./formatters/color.js'));\ne.formatNpm = new (require('./formatters/npm.js'));\ne.formatLearnboost = new (require('./formatters/learnboost.js'));\ne.formatMinilog = new (require('./formatters/minilog.js'));\ne.formatWithStack = new (require('./formatters/withstack.js'));\ne.formatTime = new (require('./formatters/time.js'));\n\nmodule.exports = e;\n","var Transform = require('../../common/transform.js');\n\nfunction FormatClean() {}\n\nTransform.mixin(FormatClean);\n\nFormatClean.prototype.write = function(name, level, args) {\n  function pad(s) { return (s.toString().length == 1? '0'+s : s); }\n  this.emit('item', (name ? name + ' ' : '') + (level ? level + ' ' : '') + args.join(' '));\n};\n\nmodule.exports = FormatClean;\n","var Transform = require('../../common/transform.js'),\n    style = require('./util.js').style;\n\nfunction FormatColor() {}\n\nTransform.mixin(FormatColor);\n\nFormatColor.prototype.write = function(name, level, args) {\n  var colors = { debug: 'magenta', info: 'cyan', warn: 'yellow', error: 'red' };\n  function pad(s) { return (s.toString().length == 4? ' '+s : s); }\n  this.emit('item', (name ? name + ' ' : '')\n          + (level ? style('- ' + pad(level.toUpperCase()) + ' -', colors[level]) + ' ' : '')\n          + args.join(' '));\n};\n\nmodule.exports = FormatColor;\n","var Transform = require('../../common/transform.js');\n\nfunction FormatNpm() {}\n\nTransform.mixin(FormatNpm);\n\nFormatNpm.prototype.write = function(name, level, args) {\n  var out = {\n        debug: '\\033[34;40m' + 'debug' + '\\033[39m ',\n        info: '\\033[32m' + 'info'  + '\\033[39m  ',\n        warn: '\\033[30;41m' + 'WARN' + '\\033[0m  ',\n        error: '\\033[31;40m' + 'ERR!' + '\\033[0m  '\n      };\n  this.emit('item', (name ? '\\033[37;40m'+ name +'\\033[0m ' : '')\n          + (level && out[level]? out[level] : '')\n          + args.join(' '));\n};\n\nmodule.exports = FormatNpm;\n","var Transform = require('../../common/transform.js'),\n    style = require('./util.js').style;\n\nfunction FormatLearnboost() {}\n\nTransform.mixin(FormatLearnboost);\n\nFormatLearnboost.prototype.write = function(name, level, args) {\n  var colors = { debug: 'grey', info: 'cyan', warn: 'yellow', error: 'red' };\n  this.emit('item', (name ? style(name +' ', 'grey') : '')\n          + (level ? style(level, colors[level]) + ' ' : '')\n          + args.join(' '));\n};\n\nmodule.exports = FormatLearnboost;\n","var Transform = require('../../common/transform.js'),\n    style = require('./util.js').style,\n    util = require('util');\n\nfunction FormatMinilog() {}\n\nTransform.mixin(FormatMinilog);\n\nFormatMinilog.prototype.write = function(name, level, args) {\n  var colors = { debug: 'blue', info: 'cyan', warn: 'yellow', error: 'red' };\n  this.emit('item', (name ? style(name +' ', 'grey') : '')\n            + (level ? style(level, colors[level]) + ' ' : '')\n            + args.map(function(item) {\n              return (typeof item == 'string' ? item : util.inspect(item, null, 3, true));\n            }).join(' '));\n};\n\nmodule.exports = FormatMinilog;\n","var Transform = require('../../common/transform.js'),\n    style = require('./util.js').style;\n\nfunction FormatNpm() {}\n\nTransform.mixin(FormatNpm);\n\nfunction noop(a){\n  return a;\n}\n\nvar types = {\n  string: noop,\n  number: noop,\n  default: JSON.stringify.bind(JSON)\n};\n\nfunction stringify(args) {\n  return args.map(function(arg) {\n    return (types[typeof arg] || types.default)(arg);\n  });\n}\n\nFormatNpm.prototype.write = function(name, level, args) {\n  var colors = { debug: 'magenta', info: 'cyan', warn: 'yellow', error: 'red' };\n  function pad(s) { return (s.toString().length == 4? ' '+s : s); }\n  function getStack() {\n    var orig = Error.prepareStackTrace;\n    Error.prepareStackTrace = function (err, stack) {\n      return stack;\n    };\n    var err = new Error;\n    Error.captureStackTrace(err, arguments.callee);\n    var stack = err.stack;\n    Error.prepareStackTrace = orig;\n    return stack;\n  }\n\n  var frame = getStack()[5],\n      fileName = FormatNpm.fullPath ? frame.getFileName() : frame.getFileName().replace(/^.*\\/(.+)$/, '/$1');\n\n  this.emit('item', (name ? name + ' ' : '')\n          + (level ? style(pad(level), colors[level]) + ' ' : '')\n          + style(fileName + \":\" + frame.getLineNumber(), 'grey')\n          + ' '\n          + stringify(args).join(' '));\n};\n\nFormatNpm.fullPath = true;\n\nmodule.exports = FormatNpm;\n\n","var Transform = require('../../common/transform.js'),\n    style = require('./util.js').style,\n    util = require('util');\n\nfunction FormatTime() {}\n\nfunction timestamp() {\n  var d = new Date();\n  return ('0' + d.getDate()).slice(-2) + '-' +\n    ('0' + (d.getMonth() + 1)).slice(-2) + '-' +\n    d.getFullYear() + ' ' +\n    ('0' + d.getHours()).slice(-2) + ':' +\n    ('0' + d.getMinutes()).slice(-2) + ':' +\n    ('0' + d.getSeconds()).slice(-2) + '.' +\n    ('00' + d.getMilliseconds()).slice(-3);\n}\n\nTransform.mixin(FormatTime);\n\nFormatTime.prototype.write = function(name, level, args) {\n  var colors = { debug: 'blue', info: 'cyan', warn: 'yellow', error: 'red' };\n  this.emit('item', style(timestamp() +' ', 'grey')\n            + (name ? style(name +' ', 'grey') : '')\n            + (level ? style(level, colors[level]) + ' ' : '')\n            + args.map(function(item) {\n              return (typeof item == 'string' ? item : util.inspect(item, null, 3, true));\n            }).join(' '));\n};\n\nmodule.exports = FormatTime;\n","var Transform = require('../common/transform.js');\n\nvar newlines = /\\n+$/,\n    logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  var i = args.length-1;\n  if (typeof console === 'undefined' || !console.log) {\n    return;\n  }\n  if(console.log.apply) {\n    return console.log.apply(console, [name, level].concat(args));\n  } else if(JSON && JSON.stringify) {\n    // console.log.apply is undefined in IE8 and IE9\n    // for IE8/9: make console.log at least a bit less awful\n    if(args[i] && typeof args[i] == 'string') {\n      args[i] = args[i].replace(newlines, '');\n    }\n    try {\n      for(i = 0; i < args.length; i++) {\n        args[i] = JSON.stringify(args[i]);\n      }\n    } catch(e) {}\n    console.log(args.join(' '));\n  }\n};\n\nlogger.formatters = ['color', 'minilog'];\nlogger.color = require('./formatters/color.js');\nlogger.minilog = require('./formatters/minilog.js');\n\nmodule.exports = logger;\n","var Transform = require('../../common/transform.js'),\n    color = require('./util.js');\n\nvar colors = { debug: ['cyan'], info: ['purple' ], warn: [ 'yellow', true ], error: [ 'red', true ] },\n    logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  var fn = console.log;\n  if(console[level] && console[level].apply) {\n    fn = console[level];\n    fn.apply(console, [ '%c'+name+' %c'+level, color('gray'), color.apply(color, colors[level])].concat(args));\n  }\n};\n\n// NOP, because piping the formatted logs can only cause trouble.\nlogger.pipe = function() { };\n\nmodule.exports = logger;\n","var Transform = require('../../common/transform.js'),\n    color = require('./util.js'),\n    colors = { debug: ['gray'], info: ['purple' ], warn: [ 'yellow', true ], error: [ 'red', true ] },\n    logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  var fn = console.log;\n  if(level != 'debug' && console[level]) {\n    fn = console[level];\n  }\n\n  var subset = [], i = 0;\n  if(level != 'info') {\n    for(; i < args.length; i++) {\n      if(typeof args[i] != 'string') break;\n    }\n    fn.apply(console, [ '%c'+name +' '+ args.slice(0, i).join(' '), color.apply(color, colors[level]) ].concat(args.slice(i)));\n  } else {\n    fn.apply(console, [ '%c'+name, color.apply(color, colors[level]) ].concat(args));\n  }\n};\n\n// NOP, because piping the formatted logs can only cause trouble.\nlogger.pipe = function() { };\n\nmodule.exports = logger;\n","var Transform = require('../common/transform.js');\n\nfunction Stringify() {}\n\nTransform.mixin(Stringify);\n\nStringify.prototype.write = function(name, level, args) {\n  var result = [];\n  if(name) result.push(name);\n  if(level) result.push(level);\n  result = result.concat(args);\n  for(var i = 0; i < result.length; i++) {\n    if(result[i] && typeof result[i] == 'object') {\n      // Buffers in Node.js look bad when stringified\n      if(result[i].constructor && result[i].constructor.isBuffer) {\n        result[i] = result[i].toString();\n      } else {\n        try {\n          result[i] = JSON.stringify(result[i]);\n        } catch(stringifyError) {\n          // happens when an object has a circular structure\n          // do not throw an error, when printing, the toString() method of the object will be used\n        }\n      }\n    } else {\n      result[i] = result[i];\n    }\n  }\n  this.emit('item',  result.join(' ') + '\\n');\n};\n\nmodule.exports = Stringify;\n","module.exports = require(\"stream\");","function RedisBackend(options) {\n  this.client = options.client;\n  this.key = options.key;\n}\n\nRedisBackend.prototype.write = function(str) {\n  this.client.rpush(this.key, str);\n};\n\nRedisBackend.prototype.end = function() {};\n\nRedisBackend.prototype.clear = function(cb) {\n  this.client.del(this.key, cb);\n};\n\nmodule.exports = RedisBackend;\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvEA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;;;;;AAKA;AAAA;AACA;AAEA;AAHA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AAXA;AACA;AAaA;;;;AAIA;AACA;AACA;AAnCA;AAoCA;AACA;AACA;;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;;AA6BA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;;;AAAA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;;;AApGA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;;;;AA9EA;AACA;AA6JA;;;;;;AAIA;AACA;;;;AAIA;AALA;AACA;AAOA;;;;;;;;;AC9LA;AACA;AACA;;;;AAIA;AACA;;;;AAIA;AACA;AACA;;;;;AAKA;AACA;AACA;;;AAGA;AACA;;;;;;;AAOA;AARA;AAjBA;;;;;;;;;;;;;ACNA;AACA;AAEA;AACA;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;;;;;;AASA;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAJA;AAhDA;AACA;AAuDA;;;;AAIA;AACA;AACA;;;;;AAKA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AAxBA;AACA;AA0BA;;;;;;;;;;;;;ACrLA;AACA;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AAMA;AACA;AACA;;;;;;;;;;AAOA;AACA;AAMA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAmCA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;;;AAxCA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAoBA;;;;;;AC1KA;;;;;;;;;;;;;;;ACAA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAHA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;;;AClQA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5CA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACnBA;AACA;AACA;;;;AAIA;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;;;;;;AAMA;AACA;AACA;;;AAGA;AACA;AACA;;;;;;;AAOA;AAAA;AACA;AACA;AAFA;AAAA;AACA;AAOA;;;;;;;;;;AAUA;AAAA;AAAA;AACA;AAKA;;;;;AAKA;AACA;AAEA;;;;;;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AAgBA;AAAA;AACA;AAEA;AAHA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvEA;AAwEA;AACA;AACA;;;;;;;;;AAcA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AACA;AADA;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAWA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AAYA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AAcA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AATA;AAWA;AACA;AACA;;;;;;;;AAQA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAKA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AAFA;AAWA;AACA;AACA;AAFA;AAZA;AAwBA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AAeA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AAYA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AAFA;AAAA;AAAA;AAGA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAqCA;;;;;AAKA;;;AAGA;AACA;AACA;;;AAlgDA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;;;AAkQA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;AA+sCA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AA7mDA;AACA;AA2nDA;AACA;AACA;AADA;AACA;AACA;;;;;;ACltDA;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;;;AACA;;;;;;AAMA;AAAA;AACA;AAEA;AAHA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAcA;AACA;AACA;;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAcA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAzDA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;;;AAqDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AA9GA;AACA;AAiHA;;;;;;;;;;;;;ACtHA;;;;;;AAMA;;;;AAIA;AACA;AACA;;;;;;;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAMA;;;;;;;;AAQA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AAMA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AAKA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;;;;;;;;;;AC7MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;;;;AAMA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AAXA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAqCA;;;AAGA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAsBA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AA9cA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;;;AA8QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AAqJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;;;ACjoBA;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;;;;;;;AAOA;AACA;AACA;AAFA;AACA;AAKA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;AACA;;;;;;;AAOA;AAAA;AACA;AAEA;;;;AAHA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AACA;AAIA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzDA;AA0DA;AACA;AACA;;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAcA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AAKA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AA4BA;AACA;AACA;AAFA;AA7BA;AACA;AA0DA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AAbA;AACA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AASA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAaA;AAhBA;AACA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AALA;AACA;AAQA;AAGA;AACA;AACA;AACA;AACA;AACA;AANA;AACA;AASA;AAEA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AA7fA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;;;;AA3FA;AACA;AAilBA;;;;;;;;;;;;;;;;;;;ACxpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;;;;;;;AAOA;AAAA;AACA;AAEA;AAHA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhBA;AAiBA;AACA;AACA;;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAOA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;;;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAOA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AA9EA;AACA;AACA;;;;AA3CA;AACA;AA0HA;;;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAOA;AACA;AAKA;AACA;AAKA;AACA;AACA;AACA;AAIA;AAcA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAIA;AACA;AAIA;AACA;AACA;AACA;AAIA;AAAA;AAAA;AAgBA;AACA;AACA;AAIA;AACA;AAIA;AACA;AACA;AAOA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAAA;AAAA;AAAA;AAAA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;;;;;;;;;;;;;;;;AC5MA;AACA;AACA;;;;;AAIA;AACA;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;;;;;AAKA;AACA;;;;;;AAGA;;;;;AAGA;;;AACA;;;;AAIA;AAAA;AACA;AADA;AACA;AACA;AAFA;AAGA;AACA;AACA;;;;;;;;;;AAMA;AACA;AACA;AAFA;AAAA;AAAA;AACA;AADA;AAGA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AATA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AASA;AACA;;;;AA3BA;AACA;AA6BA;;;;;;;;;;;;;AC9HA;AACA;AACA;AACA;;;;;;;;;;AAUA;;;;;;;;;AAQA;AACA;;;;AAIA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAGA;;;;;;AC/GA;;;;;;ACAA;;;;;;;;;ACAA;AACA;AACA;AACA;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/BA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}